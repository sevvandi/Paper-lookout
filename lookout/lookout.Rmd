---
output:
  pdf_document: default
  html_document: default
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = FALSE,
  cache = TRUE,
  messages = FALSE,
  warning = FALSE
)
library(tidyverse)
library(HDoutliers)
library(stray)
library(lookout)
library(lvplot)
# remotes::install_github("rrrlw/ggtda")
library(ggtda)
library(ggforce)
library(RANN)
library(TDAstats)
library(patchwork)
library(ggrepel)
library(latex2exp)
library(DDoutlier)
library(pROC)
library(R.matlab)

set.seed(2021)

diff_metrics <- function(act, pred) {
  # positives to be denoted by 1 and negatives with 0
  stopifnot(length(act) == length(pred))
  n <- length(act)
  tp <- sum((act == 1) & (pred == 1))
  tn <- sum((act == 0) & (pred == 0))
  fp <- sum((act == 0) & (pred == 1))
  fn <- sum((act == 1) & (pred == 0))
  prec <- (tp + tn) / n
  sn <- tp / (tp + fn)
  sp <- tn / (tn + fp)
  precision <- if_else(
    (tp + fp) == 0,
    0,
    tp / (tp + fp)
  )
  recall <- tp / (tp + fn)
  fmeasure <- if_else(
    (precision == 0) & (recall == 0),
    0,
    2 * precision * recall / (precision + recall)
  )
  tibble(
    N = n,
    true_pos = tp,
    true_neg = tn,
    false_pos = fp,
    false_neg = fn,
    accuracy = prec,
    sensitivity = sn,
    specificity = sp,
    gmean = sqrt(sn * sp),
    precision = precision,
    recall = recall,
    fmeasure = fmeasure
  )
}

col_pal2 <- col_pal1 <- c(
  "grey", "#ffffcc", "#ffeda0", "#fed976", "#feb24c",
  "#fd8d3c", "#fc4e2a", "#e31a1c", "#bd0026", "#800026"
)

diff_metrics_2 <- function(act, pred){
  # positives to be denoted by 1 and negatives with 0
  n <- length(act)
  tp <- sum((act==1)&(pred==1))
  tn <- sum((act==0)&(pred==0))
  fp <- sum((act==0)&(pred==1))
  fn <- sum((act==1)&(pred==0))

  sp <- tn/(tn + fp)


  out <- data.frame(N=n, true_pos = tp, true_neg= tn, false_pos = fp, false_neg= fn, specificity = sp)

  return(out)
}
```

# Introduction

Outliers, anomalies and novelties are often interchangeably used to describe the same concept: data points that are unusual compared to the rest. The existence of multiple words to describe similar concepts arise from the growth of outlier detection and applications in multiple research areas. Indeed, outlier detection is used in diverse applications ranging from detecting security breaches in the Internet of Things networks to identifying extreme weather events. Consequently, it is important to develop robust techniques to detect outliers, which minimize costly false positives and dangerous false negatives.

This diverse literature can be divided into approaches that use probability densities to define outliers, and those that use distances to define outliers. Outlier detection methods that use probability densities treat outliers as observations that are very unlikely given the other observations. Outlier detection methods that use distances treat outliers as observations that lie far from other observations.

In this paper, we take a probability density approach to outlier detection. We propose a new outlier detection algorithm that we call *lookout*, which uses leave-one-out kernel density estimates to identify the most unlikely observations. We address the challenge of bandwidth selection by using persistent homology --- a concept in topological data analysis --- and use extreme value theory (EVT) to identify outliers based on their leave-one-out density estimates.

The main challenge in using kernel density estimates for outlier detection is the selection of the bandwidth. @Schubert2014 employ kernel density estimates to detect outliers using $k$-nearest neighbor distances where $k$ is a user-specified parameter, which determines bandwidth. @Qin2019 employ kernel density estimates to detect outliers in streaming data. They too have a radius parameter, which is equivalent to the bandwidth that needs to be specified by the user. @Tang2017 use reverse and shared $k$ nearest neighbors to compute kernel density estimates and identify outliers. They also have a user defined parameter $k$ that denotes the reverse $k$ nearest neighbors. The oddstream algorithm  [@talagala2019anomaly] computes kernel density estimates on a 2-dimensional projection defined by the first two principal components, and so bandwidths need to be selected. We avoid subjective user-choice, and the inappropriate use of bandwidths optimized for some other purpose, by proposing  the use of persistent homology as a new tool for bandwidth selection.

Extreme Value Theory has been gaining popularity in outlier detection because of its rich, theoretical foundations. @Burridge2006 used EVT to detect outliers in time series data. @Clifton2014 used Generalized Pareto Distributions to model the tails in high-dimensional data and detect outliers. Other recent advances in outlier detection that use EVT include the stray [@stray], oddstream [@talagala2019anomaly] and HDoutliers [@wilkinson2017visualizing] algorithms. Of these three methods, stray is an enhancement of HDoutliers and both use distances to detect outliers, while oddstream uses kernel density estimates to detect outliers in time series data. Our approach is closest to oddstream in that we also apply EVT to functions of kernel density estimates. However, we use a different functional, and we avoid the need for an outlier-free training set.

A brief introduction to persistent homology and EVT is given in Section \ref{sec:methodology}. In Section \ref{sec:lookout} we introduce the algorithm *lookout* and the concept of outlier persistence, which explores the birth and death of outliers with changing bandwidth. We show examples illustrating the usefulness of outlier persistence and conduct experiments using synthetic data to evaluate the performance of lookout in Section \ref{sec:simulations}. Using an extensive data repository of real datasets, we compare the performance of lookout to HDoutliers, stray, \textcolor{blue}{KDEOS} [@Schubert2014] \textcolor{blue}{and RDOS} [@Tang2017] in Section \ref{sec:applications}.

We have produced an R package `lookout` [@lookoutR] containing this algorithm. In addition, all examples in this paper are available in the supplementary material at \url{https://github.com/sevvandi/supplementary_material/tree/master/lookout}.

We have used the R packages `TDAstats` [@tdastatsR] and `ggtda` [@ggdta] for all TDA and persistent homology computations and related graphs. We have used the R package `evd` [@evdR] to fit the Generalized Pareto Distribution.

# Mathematical background {#sec:methodology}

In this section we provide some brief background on three topics that we will use in our proposed `lookout` algorithm.

1. topological data analysis and persistent homology;
2. extreme value theory and the peaks-over-threshold approach; and
3. kernel density estimation.

## Topological data analysis and persistent homology {#subsec:tda}

Topological data analysis is the study of data using topological constructs. It is about inferring high dimensional structure from low dimensional representations such as points and assembling discrete points to construct global structures [@ghrist2008barcodes]. Persistent homology is a method in algebraic topology that computes topological features of a space that persist across multiple scales or spatial resolutions. These features include connected components, topological circles and trapped volumes. Features that persist for a wider range of spatial resolutions represent robust, intrinsic features of the data while features that sporadically change are perturbations resulting from noise. Persistent homology has been used in a wide variety of applications including biology [@topaz2015topological], computer graphics [@carlsson2008local] and engineering [@perea2015sliding]. In this section we will give a brief overview of persistent homology without delving into the mathematical details. Readers are referred to @ghrist2008barcodes and @Carlsson2009 for an overview and @wasserman2018topological for a statistical viewpoint on the subject.

### Simplicial complex {-}

Consider a data cloud representing a collection of points. This set of points is used to construct a graph where the points are considered vertices and the edges are determined by the distance between the points. Given a proximity parameter $\varepsilon$, two vertices are connected by an edge if the distance between these two points is less than or equal to $\varepsilon$. Starting from this graph, a simplicial complex --- a space built from simple pieces --- is constructed. A simplicial complex is a finite set of $k$-simplices, where $k$ denotes the dimension; for example, a point is a $0$-simplex, an edge a $1$-simplex, a triangle a $2$-simplex, and a tetrahedron a $3$-simplex. Suppose $S$ denotes a simplicial complex that includes a $k$-simplex $\gamma$. Then all non-empty subsets of $\beta \subset \gamma$ are also included in $S$. For example, if $S$ contains a triangle $pqr$, then the edges $pq$, $qr$ and $rs$, and the vertices $p$, $q$ and $r$, are also in $S$.

The *Vietoris-Rips* complex and the *Cech* complex are two types of $k$-simplicial complexes. We will construct a Vietoris-Rips complex from the data cloud as it is more computationally efficient than the Cech complex [@ghrist2008barcodes]. Given a set of points and a proximity parameter $\varepsilon > 0$, $k+1$ points within a distance of $\varepsilon$ to each other form a $k$-simplex. For example, consider 5 points $p$, $q$, $r$, $s$ and $t$ and suppose the distance between any two points except $t$ is less than $\varepsilon$. Then we can construct the edges $pq$, $pr$, $ps$, $qr$, $qs$ and $rs$. From the edges $pq$, $qr$ and $rp$ we can construct the triangle $pqr$, from $pq$, $qs$ and $sp$ the triangle $pqs$ and so on, because the distance between any two points $p$, $q$, $r$ and $s$ is bounded by $\varepsilon$. By constructing the $4$ triangles $pqr$, $qrs$, $rsp$ and $spq$ we can construct the tetrahedron $pqrs$. The vertex $t$ is not connected to this $3$-simplex because the distance between $t$ and the other vertices is greater than $\varepsilon$. The simplicial complex resulting from these 5 points consists of the tetrahedron $pqrs$ and all the subset $k$-simplices and the vertex $t$. Figure \ref{fig:tetrahedron} shows this simplicial complex on the left and another example on the right.

```{r tetrahedron, fig.height=3, fig.cap="The figure on the left shows the points $p$, $q$, $r$, $s$ and $t$ with a proximity parameter $\\varepsilon = 0.5$ and the resulting Rips complex consisting of the tetrahedron $pqrs$, triangles $pqr$, $qrs$, $rsp$, $pqs$, edges $pq$, $qr$, $rs$, $sp$, $qs$, $pr$ and vertices $p$, $q$, $r$, $s$ and $t$. The figure on the right shows $8$ points and the resulting Rips complex with $\\varepsilon=4/3$."}
d <- tibble(
  point = c("p", "q", "r", "s", "t"),
  x = c(0, 0.2, 0, 0.1, 0.75),
  y = c(0, 0.2, 0.2, 0, 0.75)
)
# compute the persistent homology
#ph <- as_tibble(TDAstats::calculate_homology(as.matrix(d[,2:3]), dim = 1))
#ph <- transform(ph, dim = as.factor(dimension))
prox <- 0.5

p1 <- ggplot(d, aes(x = x, y = y, label = point)) +
  theme_bw() +
  coord_fixed() +
  stat_disk(radius = prox / 2, fill = "aquamarine3") +
  geom_point() +
  geom_text(nudge_x = 0.08, nudge_y = 0.08) +
  stat_vietoris0() +
  stat_vietoris1(diameter = prox, alpha = .25) +
  stat_vietoris2(diameter = prox, fill = "darkgoldenrod")

X <- tibble(
  x = rnorm(8),
  y = rnorm(8)
)
# compute the persistent homology
#ph <- as.tibble(TDAstats::calculate_homology(as.matrix(X), dim = 1))
#ph <- transform(ph, dim = as.factor(dimension))

prox <- 4 / 3
p2 <- ggplot(X, aes(x = x, y = y)) +
  theme_bw() +
  coord_fixed() +
  stat_disk(radius = prox / 2, fill = "aquamarine3") +
  geom_point() +
  stat_vietoris0() +
  stat_vietoris1(diameter = prox, alpha = .25) +
  stat_vietoris2(diameter = prox, fill = "darkgoldenrod")

p1 | p2
```

### Persistent homology {-}

Given a point cloud of data, the resulting Rips complex depends on the value of the proximity parameter $\varepsilon$. As we increase $\varepsilon$, topological features such as connected components and holes appear and disappear. This is the focus of persistent homology. For example, in Figure&nbsp;\ref{fig:annulus}, we start with a large number of connected components (top-left) and as $\varepsilon$ increases to $0.8$ the number of connected components merge and decrease to 1 (bottom-left). Around this value of $\varepsilon$, a hole appears and as $\varepsilon$ increases to $1.5$, it disappears (bottom-right). The appearances and disappearances of these topological features are referred to as births and deaths and are illustrated using a *barcode* or a *persistence diagram*.

```{r annulus, fig.cap="Rips complexes resulting from different $\\varepsilon$ values.", fig.width=6, fig.height=4}
outer_radius <- 1
inner_radius <- 0.7
n <- 50
rho <- sqrt(runif(n, inner_radius^2, outer_radius^2))
theta <- runif(n, 0, 2 * pi)
X <- tibble(
  x = rho * cos(theta),
  y = rho * sin(theta)
)
#ph <- TDAstats::calculate_homology(as.matrix(X), dim = 1)
#ph <- as.tibble(ph)
#ph <- transform(ph, dim = as.factor(dimension))

prox <- 0.1
p3 <- ggplot(X, aes(x = x, y = y)) +
  theme_bw() +
  coord_fixed() +
  stat_disk(radius = prox / 2, fill = "aquamarine3") +
  geom_point() +
  stat_vietoris0() +
  stat_vietoris1(diameter = prox, alpha = .25) +
  stat_vietoris2(diameter = prox, fill = "darkgoldenrod") +
  labs(subtitle = TeX(sprintf('$\\epsilon$ = %.1f', prox))) +
  xlim(-1.75,1.75) + ylim(-1.75,1.75)

prox <- 0.3
p4 <- ggplot(X, aes(x = x, y = y)) +
  theme_bw() +
  coord_fixed() +
  stat_disk(radius = prox / 2, fill = "aquamarine3") +
  geom_point() +
  stat_vietoris0() +
  stat_vietoris1(diameter = prox, alpha = .25) +
  stat_vietoris2(diameter = prox, fill = "darkgoldenrod") +
  labs(subtitle = TeX(sprintf('$\\epsilon$ = %.1f', prox))) +
  xlim(-1.75,1.75) + ylim(-1.75,1.75)

prox <- 0.8
p5 <- ggplot(X, aes(x = x, y = y)) +
  theme_bw() +
  coord_fixed() +
  stat_disk(radius = prox / 2, fill = "aquamarine3") +
  geom_point() +
  stat_vietoris0() +
  stat_vietoris1(diameter = prox, alpha = .25) +
  stat_vietoris2(diameter = prox, fill = "darkgoldenrod") +
  labs(subtitle = TeX(sprintf('$\\epsilon$ = %.1f', prox))) +
  xlim(-1.75,1.75) + ylim(-1.75,1.75)

prox <- 1.5
p6 <- ggplot(X, aes(x = x, y = y)) +
  theme_bw() +
  coord_fixed() +
  stat_disk(radius = prox / 2, fill = "aquamarine3") +
  geom_point() +
  stat_vietoris0() +
  stat_vietoris1(diameter = prox, alpha = .25) +
  stat_vietoris2(diameter = prox, fill = "darkgoldenrod") +
  labs(subtitle = TeX(sprintf('$\\epsilon$ = %.1f', prox))) +
  xlim(-1.75,1.75) + ylim(-1.75,1.75)

(p3 | p4) / (p5 | p6)
```

```{r barcodeandpersistence, fig.cap="The graph on the left shows the barcode of the point cloud in Figure \\ref{fig:annulus} and the graph on the right shows the persistence diagram.", dependson="annulus", out.width="100%"}
# compute the persistent homology
ph1 <- TDAstats::calculate_homology(as.matrix(X), dim = 1)
# plot topological barcode
bcd <- plot_barcode(ph1)
# plot persistence diagram
pst <- plot_persist(ph1) + xlab("Birth") + ylab("Death")

bcd | pst
```

```{r include=FALSE}
longblueline <- ph1 %>% as.data.frame() %>% filter(dimension==1) %>% filter(row_number() == 1L)
beta <- ph1 %>%
  as.data.frame() %>%
  filter(birth <= 0.60, death >= 0.60)
beta0 <- beta %>% filter(dimension==0) %>% NROW()
beta1 <- beta %>% filter(dimension==1) %>% NROW()
```

Figure \ref{fig:barcodeandpersistence} shows the barcode and the persistence diagram of the point cloud shown in Figure \ref{fig:annulus}. The barcode comprises a set of horizontal line segments, each denoting a feature that starts at its birth diameter and ends at its death diameter. These line segments are grouped by their dimension. The orange lines in Figure \ref{fig:barcodeandpersistence} denote the zero dimensional holes, which are connected components and blue lines denote one dimensional holes. The longer blue line which is born at `r sprintf("%.2f",longblueline$birth)` and dies at `r sprintf("%.2f",longblueline$death)`, corresponds to the hole at the center of the point cloud in Figure \ref{fig:annulus}. Such features that continue for a large range of $\varepsilon$, represent structural properties of the data that are of interest to us. The same information is presented differently in the persistence diagram, where the birth and the death of each feature is denoted by a point. Points away from the diagonal inform about the structure of the data while points closer to the diagonal are perturbations related to noise. In this plot, the triangle near the top represents the same feature as the long blue line in the left plot.

<!-- Betti numbers denoted by $\beta_k$ give the number of $k$-dimensional holes of a simplicial complex. The number of connected components is given by $\beta_0$ and the number of one-dimensional holes is given by $\beta_1$. The number of two-dimensional holes, which are trapped volumes or voids is given by $\beta_2$. The Betti numbers can also be computed from the barcode by drawing a vertical line at the desired diameter and counting the points of intersection for each dimension. For example, in Figure \ref{fig:barcodeandpersistence} the Betti numbers corresponding to the simplicial complex at diameter $0.6$ are $\beta_0 = `r beta0`$ and $\beta_1 = `r beta1`$. -->

These considerations lead to a natural question: which $\varepsilon$ is most representative of the structure of the data cloud? We will return to this question later.

## Extreme value theory {#subsec:evt}

Extreme Value Theory is used to model rare, extremal events. It is used in many industries including hydrology (to study 100-year floods), finance (to explore extreme risks) and insurance (to mitigate against losses due to disasters) [@Reiss2001]. EVT has also been used in outlier detection [@wilkinson2017visualizing;@talagala2019anomaly]. In this section we will give a brief introduction to EVT using the notation in @coles2001introduction.

Consider $n$ independent and identically distributed random variables $X_1, \dots, X_n$ with a distribution function $F(x) = P\{X \leq x\}$. Then the maximum of these $n$ random variables is $M_n = \max \{X_1, \dots, X_n\}$. If $F$ is known, the distribution of $M_n$ is given by [@coles2001introduction, p45] $P\{M_n \leq z \} = \left(F(z)\right)^n$. However, $F$ is usually not known in practice. This gap is filled by Extreme Value Theory, which studies approximate families of models for $F^n$ so that extremes can be modeled and uncertainty quantified. The Fisher-Tippet-Gnedenko Theorem states that under certain conditions, a scaled maximum $\frac{M_n - a_n}{b_n}$ can have certain limit distributions.

\begin{theorem}[Fisher-Tippett-Gnedenko]\label{thm:FisherTippett}
	If there exist sequences $\{a_n\}$ and $\{b_n\}$ such that
	$$
		P\left\{ \frac{(M_n - a_n)}{b_n} \leq z \right\} \rightarrow G(z) \quad \text{as} \quad n \to \infty,
	$$
	where $G$ is a non-degenerate distribution function, then $G$ belongs to one of the following families:
	\begin{align}\label{eq:EVT3}
		&\text{Gumbel} :  && G(z) = \exp\left(-\exp \left[- \Big(\frac{z-b}{a}\Big) \right] \right), \quad -\infty < z < \infty , \\
		&\text{Fréchet} : && G(z) =
		\begin{cases}
			0 ,                                                           & z \leq b  , \\
			\exp \left( - \left( \frac{z-b}{a}\right)^{-\alpha} \right) , & z > b    ,
		\end{cases}                     \\
		&\text{Weibull} : && G(z) =
		\begin{cases}
			\exp \left( - \left(- \left[\frac{z-b}{a}\right]\right)^{\alpha} \right) , & z < b  ,    \\
			1 ,                                                                        & z \geq b  ,
		\end{cases}
	\end{align}
	for parameters $a, b$ and $\alpha$ where $a, \alpha >0$.
\end{theorem}

These three families of distributions can be further combined into a single family by using the following distribution function known as the Generalized Extreme Value (GEV) distribution,
\begin{equation}\label{eq:EVT4}
	G(z) = \exp\left\{ -\left[ 1 + \xi\Big(\frac{z - \mu}{\sigma} \Big)\right]^{-1/\xi} \right\} ,
\end{equation}
where the domain of the function is $\{z: 1 + \xi (z - \mu)/\sigma >0 \}$. The location parameter is $\mu\in\mathbb{R}$, $\sigma>0$ is the scale parameter, while $\xi\in\mathbb{R}$ is the shape parameter. When $\xi = 0$ we obtain a Gumbel distribution with exponentially decaying tails. When $\xi < 0$ we get a Weibull distribution with a finite upper end and when $\xi > 0$ we get a Fréchet family of distributions with polynomially decaying tails.

### The Generalized Pareto Distribution and the POT approach {-}

The Peaks Over Threshold (POT) approach regards extremes as observations greater than a threshold $u$. We can write the conditional probability of extreme events as
\begin{equation}\label{eq:POT1}
	P\left \{X > u + y \mid X > u \right \} = \frac{1 - F(u+y)}{1 - F(u)} , \quad y >0  ,
\end{equation}
giving us
\begin{equation}\label{eq:POT2}
	P\left \{X \leq u + y \mid X > u \right \} = \frac{ F(u+y) - F(u)}{1 - F(u)} , \quad y >0  .
\end{equation}
The distribution function
\begin{equation}\label{eq:POT3}
	F_u(y) = P\left \{X \leq u + y \mid X > u \right \} ,
\end{equation}
describes the *exceedances* above the threshold $u$. If $F$ is known we could compute this probability. However, as $F$ is not known in practice we use approximations based on the Generalized Pareto Distribution [@Pickands1975].
\begin{theorem}[Pickands]
  Let $X_1,  X_2, \dots,  X_n$ be a sequence of independent random variables with a common distribution function $F$, and let $M_n = \max \{X_1, \dots, X_n \}$. Suppose $F$ satisfies Theorem \ref{thm:FisherTippett} so that for large $n$, $P\{ M_n \leq z \} \approx G(z)$, where
	$$
    G(z) = \exp\left\{ -\left[ 1 + \xi\Big(\frac{z - \mu}{\sigma} \Big)\right]^{-1/\xi} \right\},
  $$
	for some $\mu, \xi \in \mathbb{R}$ and $\sigma >0$. Then for large enough $u$, the distribution function of $(X-u)$ conditional on $X > u$, is approximately
	\begin{equation}\label{eq:POT4}
		H(y) = 1 - \Big( 1 + \frac{\xi y}{\sigma_u} \Big)^{-1/\xi} ,
	\end{equation}
	where the domain of $H$ is $\{y: y >0 \text{~and~} (1 + \xi y)/\sigma_u >0 \}$, and $\sigma_u = \sigma + \xi(u- \mu)$.
\end{theorem}
The family of distributions defined by equation \eqref{eq:POT4} is called the \textbf{Generalized Pareto Distribution} (GPD). We note that the GPD parameters are determined from the associated GEV parameters. In particular, the shape parameter $\xi$ is the same in both distributions.

For a chosen threshold $u$, the parameters of the GPD can be estimated by standard maximum likelihood techniques. As an analytical solution that maximizes the likelihood does not exist, numerical techniques are used to arrive at an approximate solution. We use the R package `evd` to fit a GPD using the POT approach.

## Kernel density estimation {#subsec:kde}

For a sample $\bm{x}_1, \bm{x}_2, \dots, \bm{x}_n \in \mathbb{R}^p$, the kernel density estimate is given by
\begin{equation}\label{eq:kde6}
  \hat{f}(\bm{x}; \bm{H}) = \frac{1}{n} \sum_{i=1}^n K_{\bm{H}}\left(\bm{x} -\bm{x}_i \right) ,
\end{equation}
where $\bm{H}$ denotes a $p \times p$ positive definite bandwidth matrix, $K_{\bm{H}}(\bm{z}) = \bm{H}^{-1/2} K(\bm{H}^{-1/2} \bm{z})$, and $K$ is a kernel function.
For consistency, we scale the kernels so that $\int \|\bm{z}^2\| K(\bm{z}) d\bm{z} = 1$. The multivariate Gaussian kernel is given by
\begin{equation}\label{eq:kde7}
  K(\bm{x}) = \frac{1}{(2\pi)^{p/2}} \exp( \| \bm{x} \| ^2/2) ,
\end{equation}
and the multivariate scaled Epanechnikov kernel by
\begin{equation}\label{eq:kde8}
  K(\bm{x}) = \frac{p+2}{c_p}(1 - \| \bm{x} \| ^2 / 5)_+  ,
\end{equation}
where $c_p$ is the volume of the unit sphere in $\mathbb{R}^p$ and $u_+ = \max(0,u)$.

We will use the leave-one-out kernel density estimator given by
\begin{equation}\label{eq:kde9}
	\hat{f}_{-j}(\bm{x};\bm{H}) = \frac{1}{n-1}\sum_{i \neq j} K_{\bm{H}}(\bm{x}-\bm{x}_i),
\end{equation}
which can be simplified to
\begin{equation}\label{eq:kde9b}
  \hat{f}_{-j}(\bm{x}_j;\bm{H}) = \big[n\hat{f}(\bm{x}_j;\bm{H}) - \bm{H}^{-1/2}K(\bm{0})\big]/(n-1)
\end{equation}
when evaluated at the observation omitted.

A major challenge in using kernel density estimates for outlier detection is selecting the appropriate bandwidth. There is a large body of literature on kernel density estimation and bandwidth selection [@Scott1994;@Wang2019] that focuses on computing density estimates that represent the data as accurately as possible, where measures of accuracy have certain asymptotic properties.  However, our goal is somewhat different as we are interested in finding outliers in the data, rather than finding a good representation for the rest of the data. Often the usual bandwidth selection methods result in bandwidths that are too small and can cause the kernel density estimates of the boundary and near-boundary points to be confused with outliers. In high dimensions this problem is exacerbated due to the sparsity of the data. Thus, we need a bandwidth that assists outlier detection. A too small bandwidth causes everything to be outliers, while too large a bandwidth will lead to outliers being hidden.

# Methodology {#sec:lookout}

## Bandwidth selection using TDA {#subsec:selectingBandwidth}

To select a bandwidth for a kernel density estimate designed for outlier detection, we propose to use the barcode discussed in Section \ref{subsec:tda}. First we construct the barcode of the data cloud for dimension zero using the Vietoris-Rips diameter. From the barcode we obtain the sequence of death diameters $\{d_i\}_{i = 1}^N$ for the connected components. By construction this is an increasing sequence as seen in Figure \ref{fig:barcodeandpersistence}. 

```{r TDAKNN, fig.cap="Top left: A scatterplot of 1000 observations with most points falling on an annulus and some points near the center. Its TDA barcode on the top right and the violin plot of TDA death diameters and KNN distances at the bottom.", out.width="100%"}
oo <- 10
outer_radius <- 1
inner_radius <- 0.7
n <- 1000 - oo
rho <- sqrt(abs(rnorm(n, mean = 5, sd = 1)))
theta <- runif(n, 0, 2 * pi)
X <- bind_rows(
  tibble(
    x = rho * cos(theta),
    y = rho * sin(theta)
  ),
  tibble(
    x = rnorm(oo, mean = 0, sd = 0.2),
    y = rnorm(oo, mean = 0, sd = 0.2)
  )
)
g1 <- ggplot(X, aes(x, y)) +
  geom_point() +
  theme_bw()

# KNN distances
phom <- calculate_homology(X, dim = 0)
top2 <- tail(phom[,"death"],2)
df <- tibble(
    Type = "TDA",
    Distance = phom[,"death"]
  )
nn_obj <- RANN::nn2(X, k = 10+1)
for (kk in c(1, 5, 10)) {
  df <- bind_rows(df,
    tibble(
      Type = rep(paste0("NN_", kk), NROW(nn_obj$nn.dists)),
      Distance = nn_obj$nn.dists[, kk+1]
    )
  )
}

data_summary <- function(x) {
  m <- mean(x)
  ymin <- m - sd(x)
  ymax <- m + sd(x)
  return(c(y = m, ymin = ymin, ymax = ymax))
}
g3 <- ggplot(df, aes(x = Type, y = Distance, fill = Type)) +
  geom_violin(trim = FALSE) +
  stat_summary(fun.data = data_summary) +
  scale_fill_brewer(palette = "Dark2") +
  xlab("Distance Type") +
  theme_bw()

g2 <- plot_barcode(phom) + 
  geom_vline(xintercept = top2[1], lty = 2)

g4 <- plot_barcode(tail(phom, 20)) + 
  geom_vline(xintercept = top2[1], lty = 2)
# g4

(g1 / g3) | (g2 / g4)
```

Consider the example shown in Figure \@ref(fig:TDAKNN). At the top left, the data are shown with most points lying on an annulus, and a few points near the centre. The barcodes for dimension 0 are shown at the top right, with lengths equal to the death diameters $\{d_i\}_{i = 1}^N$. The bottom left panel shows  violin plots comparing the death diameters (denoted by TDA) with $k$ nearest neighbor distances for $k \in \{1, 5, 10\}$. The TDA Rips diameters fall within the range of the combined KNN distances. Consequently, we can use TDA distances without having to select the parameter $k$ for KNN distances.

The plot on the bottom right in Figure \ref{fig:TDAKNN} shows the largest 20 Rips diameters (out of the `r NROW(phom)` diameters shown in the top right plot). A vertical dashed line is drawn at diameter `r sprintf("%.3f",top2[1])`, the second largest Rips diameter. As the diameter increases from `r sprintf("%.3f",top2[1])` till `r sprintf("%.3f",top2[2])`, which is the maximum diameter, the number of connected components stay the same. For this point cloud, $(`r sprintf("%.3f",top2[1])`, `r sprintf("%.3f",top2[2])`)$ is the largest diameter range for which the number of components stay the same. Thus, it signifies a global structural property of the point cloud. We want to take this structure into account when selecting the bandwidth. Therefore, we choose a diameter that gives rise to persisting features, which in our case are connected components. We consider the Rips diameter intervals $(d_i, d_{i+1})$ for all $i$, and find the largest interval by computing successive differences
$\Delta d_i = d_{i+1} - d_i$, for $i \in \{1, \cdots, N-1 \}$. We choose the Rips diameter $d_i$ corresponding to the maximum $\Delta d_i$:
\begin{equation}\label{eq:deathrad2}
	d_* = d_{i_*} \qquad \text{where ~} i_*  = \argmax \{ \Delta d_i \}_{i=1}^{N-1}.
\end{equation}
Then the bandwidth matrix is given by
\begin{equation}\label{eq:bandwidth}
	\bm{H} = d_*^{2/p} \bm{I},
\end{equation}
so that
\begin{align}\label{eq:kde11}
	\| \bm{H}^{-1/2}(\bm{x} - \bm{x}_i) \|^2
	  %& = (\bm{x} - \bm{x}_i)^T (\bm{H}^{-1/2})^T \bm{H}^{-1/2} (\bm{x} - \bm{x}_i)  , \notag \\
	  %& = (\bm{x} - \bm{x}_i)^T \bm{H}^{-1} (\bm{x} - \bm{x}_i)  , \notag                                \\
	  %& = \frac{1}{h^p}(\bm{x} - \bm{x}_i)^T (\bm{x} - \bm{x}_i) , \notag                                \\
	  & = \frac{1}{d_*^2}\|\bm{x} - \bm{x}_i \|^2  .
\end{align}
This ensures that points within a distance of $d_*$ contribute to the kernel density estimate of $\bm{x}$, resulting in the following leave-one-out kernel density estimate
\begin{align}\label{eq:kde12}
	\hat{f}_{-j}(\bm{x}_j;\bm{H})
	  %& = \left[ n \hat{f}(\bm{x}_j;\bm{H}) - \bm{H}^{-1/2}K(\bm{0})\right]/(n-1)  \\
	  & = \big[ n \hat{f}(\bm{x}_j;\bm{H}) - d_*^{-1} K(\bm{0})\big]/(n-1).
\end{align}

<!-- ```{r epsilonandkernels, fig.height=3, fig.cap="The plot on the top shows two points that are $\\varepsilon = 1$ distance away from each other. The plots at the bottom show a Gaussian and an Epanechnikov kernel, with bandwidth $1$ and $2$ respectively. The choice of bandwidth makes each point contribute to the other's kernel density estimate.", fig.height=5} -->
<!-- X <- tibble( -->
<!--   x = c(0,1), -->
<!--   y = c(0,0) -->
<!-- ) -->
<!-- prox <- 1 -->
<!-- g5 <- ggplot(X, aes(x = x, y = y)) + -->
<!--   theme_bw() + -->
<!--   coord_fixed() + -->
<!--   stat_disk(radius = prox / 2, fill = "aquamarine3") + -->
<!--   geom_point() + -->
<!--   geom_segment(x = 0, y = 0, xend = 1, yend = 0, arrow = arrow(length = unit(0.03, "npc"))) + -->
<!--   geom_text(x = 0.5, y = 0.05, label = "1") -->

<!-- Y <- tibble(x = seq(-2, 2, length = 1000)) %>% -->
<!--   mutate(y = dnorm(x, mean = 0, sd = 1)) -->
<!-- g6 <- ggplot(Y, aes(x, y)) + -->
<!--   geom_line() + -->
<!--   geom_point(x = 0, y = 0) + -->
<!--   geom_point(x = 1, y = 0) + -->
<!--   geom_segment(x = 0, y = 0, xend = 1, yend = 0) + -->
<!--   coord_fixed(ratio = 4) + -->
<!--   geom_vline(xintercept = 0, lty = 2) + -->
<!--   geom_segment(x = 1, y = -0.15, xend = 1, yend = 0.23, lty = 2) + -->
<!--   geom_ellipse(aes(x0 = 0, y0 = 0, a = 0.5, b = 0.125, angle = 0), inherit.aes = FALSE) + -->
<!--   geom_ellipse(aes(x0 = 1, y0 = 0, a = 0.5, b = 0.125, angle = 0), inherit.aes = FALSE) + -->
<!--   theme_bw() -->

<!-- Y <- tibble(x = seq(-2, 2, length = 1000)) %>% -->
<!--   mutate(y = sqrt(4 - x^2)) -->
<!-- g7 <- ggplot(Y, aes(x, y)) + -->
<!--   geom_line() + -->
<!--   geom_point(x = 0, y = 0) + -->
<!--   geom_point(x = 1, y = 0) + -->
<!--   geom_segment(x = 0, y = 0, xend = 1, yend = 0) + -->
<!--   coord_fixed(ratio = 1) + -->
<!--   geom_vline(xintercept = 0, lty = 2) + -->
<!--   geom_segment(x = 1, y = -0.5, xend = 1, yend = 1.7, lty = 2) + -->
<!--   geom_circle(aes(x0 = 0, y0 = 0, r = 0.5), inherit.aes = FALSE) + -->
<!--   geom_circle(aes(x0 = 1, y0 = 0, r = 0.5), inherit.aes = FALSE) + -->
<!--   theme_bw() -->

<!-- g5 / (g6 | g7) + plot_layout(heights=c(1,1)) -->
<!-- ``` -->

<!-- Consider two points in the point cloud that are $\varepsilon = 1$ distance away as shown in Figure \ref{fig:epsilonandkernels}. Suppose we want these two points to contribute to each others kernel density estimates. This is illustrated in the bottom row of Figure \ref{fig:epsilonandkernels}. This can be achieved by using a range of bandwidth values. Let us consider a 1-dimensional dataset. For an Epanechnikov kernel, any bandwidth $h>\varepsilon$ would suffice. But, a larger bandwidth will make the contribution of the neighboring point higher than a smaller bandwidth. For a Gaussian kernel, there is no such restriction as any $h$ would include the other point. However, a small $h < < \varepsilon$ would make the contribution of the other point quite small. As such, we choose $h=\varepsilon$ for a Gaussian kernel where $\varepsilon$ denotes a particular choice of the Rips diameter. For the Epanechnikov kernel, we choose $h = \sqrt{5} \varepsilon$, so that it matches the variance of the Gaussian kernel. -->

## Algorithm *lookout*

Now we have all the building blocks necessary to describe the algorithm *lookout*. Consider an $N \times p$ data matrix $\bm{X}$ with $N$ observations in $\mathbb{R}^p$. It is customary in outlier detection to scale the data so that all variables contribute equally to outlier detection. We normalize the data using Min-Max normalization, which scales each attribute to $[0, 1]$ and has been shown to be effective compared to other normalization techniques [@kandanaarachchi2018normalization]. To accommodate datasets that do not need to be normalized, we make normalization a user option.

We compute the kernel density estimates defined by \eqref{eq:kde6} and the leave-one-out kernel density estimates defined in \eqref{eq:kde12}, with the bandwidth matrix \eqref{eq:bandwidth}, and the scaled Epanechnikov kernel \eqref{eq:kde8}.

Denote the kernel density estimate of $\bm{x}_i$ by $y_i$ and the leave-one-out kde of $\bm{x}_i$ (by leaving out $\bm{x}_i$) by $y_{-i}$. Then we fit a Generalized Pareto Distribution to $-\log(y_i)$ using the POT approach discussed in Section \ref{subsec:evt}. We use the $90^{\text{th}}$ percentile as the threshold for the POT approach as recommended by @bommier2014peaks. Using the fitted GPD parameters, $\mu$, $\sigma$ and $\xi$, we declare points with $P\left(-\log(y_{-i})|\mu, \sigma,\xi \right) < \alpha$ to be outliers. We summarize these steps in Algorithm \ref{algo:lookout}.

\DontPrintSemicolon
\begin{algorithm}\fontsize{11}{16}\selectfont
	\SetKwInOut{Input}{input~~~}
	\SetKwInOut{Output}{output}
	\Input{~ The data matrix $\bm{X}$, parameters $\alpha$ and \textit{unitize}.}
	\Output{~ The outliers, the GPD probabilities of all points, GPD parameters and bandwidth}
	If \textit{unitize = TRUE}, then normalize the data so that each column is scaled to $[0,1]$.\\
	Construct the persistence homology barcode of the data. \\
	Find $d_*$ as in equation \eqref{eq:deathrad2}. \\
	Using $\bm{H} = (d_*)^{2/p}\bm{I}$, compute kernel density estimates \eqref{eq:kde6} and leave-one-out kernel density estimates \eqref{eq:kde12} using the scaled Epanechnikov kernel \eqref{eq:kde8}. \\
	Denote the kde of $\bm{x}_i$ by $y_i$ and leave-one-out kde by $y_{-i}$.\\
	Using the POT approach, fit a GPD to $\{-\log(y_i)\}_{i=1}^N$ and estimate $\mu, \sigma$ and $\xi$. \\
	Using the GPD estimates $\hat\mu$, $\hat\sigma$ and $\hat\xi$, find the probability of the leave-one-out kde values $\{-\log(y_{-i})\}_{i=1}^N$, i.e., $P\left(-\log(y_{-i})|\mu, \sigma, \xi \right)$ for all $i$. \\
	If $P\left(-\log(y_{-i})|\mu, \sigma, \xi \right) < \alpha$, then declare $\bm{x}_i$ as an outlier.
	\caption{\itshape lookout.}
	\label{algo:lookout}
\end{algorithm}

The output probability of lookout is the GPD probability of the points, so that low probabilities indicate likely outliers and high probabilities indicate normal points. Note that the scaling factor of the kernel $K(\bm{x})$ does not affect the GPD parameters as it is just an offset after taking logs of $y_i$ or $y_i$. 

The algorithm lookout has only 2 inputs, $\alpha$ and *unitize*. The parameter $\alpha$ determines the threshold for outlier detection and *unitize* gives the user an option to normalize the data. We set $\alpha= 0.05$ and *unitize* = `TRUE` as default parameter values. We use the Epanechnikov kernel in lookout due to ease of computation. However, any kernel can be incorporated as long as the variances are matched.

## Outlier persistence {#subsec:persistence}

Lookout identifies outliers by selecting an appropriate bandwidth using TDA. If the bandwidth is changed, will the original outliers be still identified as outliers by lookout? We explore this question by varying bandwidth values in lookout. Similar work is discussed by @Minnotte1993, who introduce the Mode Tree, which tracks the modes of the kernel density estimates with changing bandwidth values. Another related idea is the SiZer map [@Chaudhuri1999], a graphical device that studies features of curves for varying bandwidth values.

```{r outlierpersistence, fig.height=3, fig.cap="Outliers at the center of the annulus in the left plot showing the outlier labels 1001--1005. The outlier persistence diagram on the right with the y-axis denoting the labels. The dashed line shows the lookout bandwidth $d_*$.", out.width="100%"}
oo <- 5
outer_radius <- 1
inner_radius <- 0.7
n <- 1000
rho <- sqrt(abs(rnorm(n, mean = 5, sd = 1)))
theta <- runif(n, 0, 2 * pi)
X <- bind_rows(
  tibble(
    x = rho * cos(theta),
    y = rho * sin(theta)
  ),
  tibble(
    x = rnorm(oo, mean = 0, sd = 0.2),
    y = rnorm(oo, mean = 0, sd = 0.2)
  )
)

g1 <- ggplot(X, aes(x, y)) +
  geom_point() +
  geom_text_repel(
    data = tail(X, 5) %>% mutate(lab = 1001:1005),
    aes(x, y, label = lab)
  ) +
  theme_bw()

lookobj <- lookout(X)
outnew <- persisting_outliers(X, num_steps = 20)
g2 <- autoplot(outnew, alpha = 0.05) +
  geom_vline(xintercept = lookobj$bandwidth, linetype = "dashed")

g1 | g2
```

If a point is identified as an outlier by the lookout algorithm for a range of bandwidth values, then it increases the validity of that point as an outlier. Consider an annulus with some points in the middle as shown in the left plot of Figure \ref{fig:outlierpersistence}. The plot on the right, which is similar to a barcode, shows the outliers identified by lookout for different bandwidth values. Each horizontal line segment shows the range of Rips diameter values that has identified each point as an outlier. With some abuse of notation, we label the $x$ axis "bandwidth", even though it actually represents the Rips diameter $d_* = h^{p/2}$, where the bandwidth matrix $\bm{H} = h\bm{I}$. This is motivated from equation \eqref{eq:kde11}, as we only consider points $\bm{x}_i$ within a distance $d_*$ of every point $\bm{x}$ when computing kernel density estimates using the Epanechnikov kernel. In this plot, the y-axis corresponds to the point index. We call this plot *the outlier persistence diagram* signifying the link to topological data analysis.

In the example in Figure \ref{fig:outlierpersistence}, we see that the points 1001--1005 are identified as outliers in the outlier persistence diagram for a large range of bandwidth values. The Rips diameter $d_*$ selected by lookout is shown by a vertical dashed line. Many points are identified as outliers for small bandwidth values but do not continue to be outliers for long; these outliers are born at small bandwidth values and die out after a relatively short increase in bandwidth. Some points are never identified as outliers, even at small bandwidths.

The outlier persistence diagram is a tool to observe the persistence of outliers with changing bandwidth values. We vary the bandwidth values  while keeping the GPD parameters fixed at the values obtained using $d_*$ as in equation \eqref{eq:deathrad2}. The death diameter sequence $d_i$ is used to construct the set of bandwidth values used in this plot. We use $\ell$ bandwidth values starting from the $\beta^{\text{th}}$ percentile of sequence $\{d_i\}$ ending at $\sqrt{5} \times \max_i{d_i}$. The parameters $\ell$ and $\beta$  are user-defined with default values $\ell = 20$ and  $\beta= 90$. Increasing $\ell$ gives better granularity but increases the computational burden. As the death diameters are tightly packed, the default value of $90^{\text{th}}$ percentile gives a small enough starting bandwidth and $\sqrt{5} \max_i{d_i}$ gives a large ending bandwidth.
We summarize these steps in Algorithm \ref{algo:persistence}.

\DontPrintSemicolon
\begin{algorithm}\fontsize{11}{16}\selectfont
	\SetKwInOut{Input}{input~~~}
	\SetKwInOut{Output}{output}
	\Input{~ The data matrix $\bm{X}$, parameters $\alpha$, \textit{unitize} and bandwidth range parameters $\ell$ and $\beta$}
	\Output{~ An $N \times \ell $ binary matrix $\bm{Y}$ where $N$ denotes the number of observations and $\ell$ denotes the number of bandwidth values with $y_{ik} = 1$ if the $i^{\text{th}}$ observation is identified as an outlier for bandwidth index ${k}$. }
	Initialize matrix $\bm{Y}$ to zero. \\
	Run Algorithm \ref{algo:lookout} to determine the death diameter sequence $\{d_i\}$ and the GPD parameters $\mu_0$, $\sigma_0$ and $\xi_0$. \\
	Construct an equidistant bandwidth sequence of length $\ell$ starting from the $\beta^{\text{th}}$ percentile of $\{d_i\}$ to $\sqrt{5} \max_i d_i$. Call the bandwidth sequence $\{b_k\}_{k=1}^{\ell}$. \\
	\For{$k$ from $1$ to $\ell$}{
	Using $h = (b_k)^{2/p}$ and $\bm{H} = h\bm{I}$ compute kernel density estimates and leave-one-out kernel density estimates using the scaled Epanechnikov kernel. \\
	Denote the kde of $\bm{x}_i$ by $y_i$ and leave-one-out kde by $y_{-i}$.\\
	Using the GPD parameters $\mu_0, \sigma_0$ and $\xi_0$ find the GPD probability of the leave-one-out kde values $\{-\log(y_{-i})\}_{i=1}^N$, i.e., $P\left(-\log(y_{-i})|\mu_0, \sigma_0, \xi_0 \right)$ for all $i$. \\
	If $P\left(-\log(y_{-i})|\mu_0, \sigma_0, \xi_0 \right) < \alpha$, then declare $\bm{x}_i$ as an outlier and let $y_{ik} = 1$.
	}
	\caption{\itshape outlier persistence for fixed $\alpha$.}
	\label{algo:persistence}
\end{algorithm}

Next, we extend this notion of persistence to include significance levels $\alpha \in \{0.01,  0.02,  \dots,  0.1 \}$.

We define the *strength* of an outlier based on its significance level. Let $\bm{x}_j$ be an outlier identified at significance level $\alpha$, where $\alpha$ is the smallest significance level for which $\bm{x}_j$ is identified as an outlier. Then
\begin{equation}\label{eq:strengthpersistence}
	\text{strength} (\bm{x}_j) = \frac{(0.11 - \alpha)_+}{0.01}
\end{equation}
Thus, if a point is identified as an outlier with a significance level $\alpha = 0.01$, then it has strength 10, and an outlier with $\alpha = 0.1$ has strength 1. To compute persistence over significance levels, the only modification that needs to be done to Algorithm \ref{algo:persistence} is to fix $\alpha = 0.1$ and to record the minimum significance level if $P\left(-\log(y_{-i})|\mu_0, \sigma_0, \xi_0 \right) < 0.1$.
Then we can use equation \eqref{eq:strengthpersistence} to compute its strength.

```{r outlierpersistence2, fig.width=6, fig.height=3, dependson="outlierpersistence", fig.cap="Outlier persistence over different bandwidth values and their strengths. The dashed line corresponds to the lookout bandwidth $d_*$.", dependson="outlierpersistence"}
autoplot(outnew) +
  geom_vline(xintercept = lookobj$bandwidth, linetype = "dashed")
```

Figure \ref{fig:outlierpersistence2} shows the persistence of outliers over different bandwidth values and significance levels for the dataset in Figure \ref{fig:outlierpersistence}. We see that points 1001--1005 are identified as outliers with high strength even for large bandwidths. This gives a comprehensive representation of outliers as it encapsulates the bandwidth as well as the strength (which corresponds to significance).

## \textcolor{blue}{Time series outliers} {#sec:timeseriesoutiers}

\textcolor{blue}{Following} @Burridge2006 \textcolor{blue}{we extend lookout to a time series setting. They consider a time series with $k$ additive outliers defined as }

$$ z_t = y_t + \sum_{j=1}^k \mathcal{I}_{\tau_j} x_{\tau_j} \, , $$ 
\textcolor{blue}{where} 
$$ \mathcal{I}_{\tau_j} =  \begin{cases} 
      1\, , & t = \tau_j \\
      0\, ,  & t \neq \tau_j
   \end{cases} \, ,
$$
\textcolor{blue}{and }
$$ y_t = \phi y_{t-1} + u_t \, , $$
\textcolor{blue}{with $\{u_t\}$ an autoregressive moving average process. They consider the case when  $\phi = 1$  and estimate $x_{\tau_j}$ by }
$$ \hat{x}_{\tau_j} = \frac{1}{2}\left(\Delta z_{\tau_j} - \Delta z_{\tau_j +1}  \right)  = \frac{1}{2}\left(\Delta y_{\tau_j} - \Delta y_{\tau_j +1}  + 2 x_{\tau_j}\right) \, .$$
\textcolor{blue}{ From the spacings of $\hat{x}_{t}$ they find outliers using  Algorithm 1 in their paper. Due to successive differences each outlier in $\{z_{t}\}$ can give rise to 3 consecutive outliers in $\{\hat{x}_{t}\}$. We extend lookout to a time series setting by using it on $\{\hat{x}_{t}\}$. To mitigate for successive outliers, we select the observation with the highest strength or the lowest probability from each set of consecutive outliers. }


# Experiments with synthetic data {#sec:simulations}

In this section we first explore outlier persistence using simple examples. Then we conduct experiments using synthetic data comparing lookout to HDoutliers [@wilkinson2017visualizing],  stray [@stray], \textcolor{blue}{KDEOS} [@Schubert2014] and \textcolor{blue}{RDOS} [@Tang2017].  Both HDoutliers and stray  use extreme value theory to detect outliers; KDEOS and RDOS use kernel density estimates. 

## Outlier persistence examples {#sec:PersistenceExamples}

```{r persistenceEx, fig.cap="Examples of outlier persistence and strength. The left column shows the data with the outliers identified by lookout with $\\alpha = 0.1$ colored by its strength. The right column shows the outlier persistence diagrams for these examples. The dashed line corresponds to the lookout bandwidth.", fig.height=6.5, fig.asp=1.2, out.width="100%"}
# ---------------------------------------------------------------------
# TASK 1 - EXAMPLE 1
# ---------------------------------------------------------------------
X <- bind_rows(
  tibble(
    x = rnorm(500),
    y = rnorm(500)
  ),
  tibble(
    x = rnorm(5, mean = 10, sd = 0.2),
    y = rnorm(5, mean = 10, sd = 0.2)
  )
)
outnew <- persisting_outliers(X, unitize = FALSE)
g2 <- autoplot(outnew) +
  geom_vline(xintercept = outnew$lookoutbw, linetype = "dashed") 

lookobj <- lookout(X, unitize = FALSE, alpha = 0.1)
X2 <- X %>%
  mutate(strength = pmax(0, (0.11 - lookobj$outlier_probability) / 0.01))
g1 <- ggplot(X2, aes(x, y)) +
  geom_point(aes(color = strength)) +
  scale_colour_gradientn(colours = col_pal2) +
  theme_bw() +
  theme(legend.position = "none")

extra_outlier <- X2 %>%
  filter(strength > 0, strength < 2)

# ---------------------------------------------------------------------
# TASK 2 - EXAMPLE 2
# ---------------------------------------------------------------------
X <- bind_rows(
  tibble(
    x = rnorm(500, mean = -10),
    y = rnorm(500),
  ),
  tibble(
    x = rnorm(500, mean = 10),
    y = rnorm(500)
  ),
  tibble(
    x = rnorm(5, sd = 0.2),
    y = rnorm(5, sd = 0.2)
  )
)

outnew <- persisting_outliers(X, unitize = FALSE)
g4 <- autoplot(outnew) +
  geom_vline(xintercept = outnew$lookoutbw, linetype = "dashed") +
  ylab("") +
  theme(legend.position = "none")

lookobj <- lookout(X, unitize = FALSE, alpha = 0.1)
X2 <- X %>%
  mutate(strength = pmax(0, (0.11 - lookobj$outlier_probability) / 0.01))
g3 <- ggplot(X2, aes(x, y)) +
  geom_point(aes(color = strength)) +
  scale_colour_gradientn(colours = col_pal2) +
  theme_bw() +
  ylab("") +
  theme(legend.position = "none")

# ---------------------------------------------------------------------
# TASK 3 - EXAMPLE 3
# ---------------------------------------------------------------------
X <- bind_rows(
  tibble(
    x = rnorm(500),
    y = rnorm(500)
  ),
  tibble(
    x = rnorm(100, sd = 0.7),
    y = rnorm(100, mean = 8, sd = 0.7)
  ),
  tibble(
    x = rnorm(100, mean = 8, sd = 0.7),
    y = rnorm(100, sd = 0.7)
  ),
  tibble(
    x = rnorm(3, mean = 6, sd = 0.2),
    y = rnorm(3, mean = 6, sd = 0.2)
  )
)
outnew <- persisting_outliers(X, unitize = FALSE)
g6 <- autoplot(outnew) +
  ylab("") +
  geom_vline(xintercept = outnew$lookoutbw, linetype = "dashed") +
  theme(legend.position = "none")

lookobj <- lookout(X, unitize = FALSE, alpha = 0.1)
X2 <- X %>%
  mutate(strength = pmax(0, (0.11 - lookobj$outlier_probability) / 0.01))
g5 <- ggplot(X2, aes(x, y)) +
  geom_point(aes(color = strength)) +
  ylab("") +
  scale_colour_gradientn(colours = col_pal2) +
  theme_bw() +
  theme(legend.position = "none")

# ---------------------------------------------------------------------
# TASK 4 - EXAMPLE 4
# ---------------------------------------------------------------------
X <- bind_rows(
  tibble(
    x = rnorm(500),
    y = rnorm(500)
  ),
  tibble(
    x = rnorm(100, sd = 0.7),
    y = rnorm(100, mean = 8, sd = 0.7)
  ),
  tibble(
    x = rnorm(100, mean = 8, sd = 0.7),
    y = rnorm(100, sd = 0.7)
  ),
  tibble(
    x = c(5,8,12),
    y = c(5, 7.5, 4)
  )
)
outnew <- persisting_outliers(X, unitize = FALSE)
g8 <- autoplot(outnew) +
  geom_vline(xintercept = outnew$lookoutbw, linetype = "dashed") +
  ylab("") +
  theme(legend.position = "none")

lookobj <- lookout(X, unitize = FALSE, alpha = 0.1)
X2 <- X %>%
  mutate(strength = pmax(0, (0.11 - lookobj$outlier_probability) / 0.01))
g7 <- ggplot(X2, aes(x, y)) +
  geom_point(aes(color = strength)) +
  ylab("") +
  scale_colour_gradientn(colours = col_pal2) +
  theme_bw() +
  theme(legend.position = "none")

# ---------------------------------------------------------------------
# TASK 5 - EXAMPLE 5
# ---------------------------------------------------------------------
X <- bind_rows(
  tibble(x = rnorm(1000, sd = 0.2)) %>%
    mutate(y = x^2 + rnorm(1000, sd = 0.01)),
  tibble(
    x = c(0, -0.2, 0.4),
    y = c(0.3, 0.4, 0.5)
  )
)

outnew <- persisting_outliers(X, unitize = FALSE)
g10 <- autoplot(outnew) +
  geom_vline(xintercept = outnew$lookoutbw, linetype = "dashed") +
  ylab("") +
  theme(legend.position = "none")

lookobj <- lookout(X, unitize = FALSE, alpha = 0.1)
X2 <- X %>%
  mutate(strength = pmax(0, (0.11 - lookobj$outlier_probability) / 0.01))
g9 <- ggplot(X2, aes(x, y)) +
  geom_point(aes(color = strength)) +
  ylab("") +
  scale_colour_gradientn(colours = col_pal2) +
  theme_bw() +
  theme(legend.position = "none")

(g1 / g3 / g5 / g7 / g9) |
  (g2 / g4 / g6 / g8 / g10)
```

Figure \ref{fig:persistenceEx} shows five examples in $\mathbb{R}^2$, each showing the data, outliers identified by lookout, their strengths and the corresponding outlier persistence diagram. In each example, the outliers are placed at the end of the synthetic dataset, i.e. their observation indices are the highest. The dashed lines in the outlier persistence diagram indicate the bandwidth chosen by lookout. The top left plot shows normally distributed data with 5 outliers in the top right corner, which are identified by lookout with high strength. Upon close inspection we see two further points, both approximately at $(`r sprintf("%.1f", mean(extra_outlier[['x']]))`, `r sprintf("%.1f", mean(extra_outlier[['y']]))`)$ and slightly detached from the main group of points, also being identified by lookout as outliers with low strength. The lookout strength of each of these points is less than 2, and so they would only be identified as outliers when $\alpha > `r 0.11 - 2*0.01`$. The corresponding persistence diagram shows high strength outlier persistence for the points at the top right hand corner. Similarly, from other graphs in column 1, we see that outliers far from high density regions are identified by lookout with high strength and points outside high density regions, but not so far away are identified with low strength. For the example in row 3, lookout has identified a cluster of outliers approximately at $(6,6)$ with high strength as well as individual points slightly away from high density regions with low strength. The example in row 5 has single outliers rather than clusters, which are again identified by lookout. For the last example in the bottom row, lookout has identified a cluster of outliers at $(-0.6, 0.35)$ with low strength and the remaining outliers with high strength. From the persistence diagrams we see that many points are identified as outliers for low bandwidth values, but only a small number of outliers persist until the bandwidth is large. In addition, some outliers persist at low strength values. For example, the persistence diagram in row 5 has outliers around index 500 with low strength persisting until large bandwidth values.

From the examples in Figure \ref{fig:persistenceEx} we see that lookout selects a bandwidth appropriate for outlier detection that is neither too small nor too large. In addition, lookout identifies outliers correctly. The outlier persistence diagram gives a snapshot of the outliers for varying bandwidths and significance levels increasing our understanding of the dataset and its outliers.

## Comparison Study {#sec:SyntheticComparison}

In this section we conduct three experiments with synthetic data. Each experiment considers two data distributions; the main distribution and a handful of outliers which are distributed differently. There are several iterations to each experiment. The iterations serve as a measure of the degree of outlyingness of the small sample. The outliers start off with the main distribution and slowly move out of the main distribution with each iteration. Consequently, in the initial iterations the points in the outlying distribution are not actual outliers as they are similar to the points in the main distribution, while in the later iterations they are quite different from the main distribution. We repeat each iteration 10 times to account for the randomness of the data generation process.

We compare the results of lookout with \textcolor{blue}{4} other algorithms; HDoutliers [@wilkinson2017visualizing], stray [@stray], \textcolor{blue}{KDEOS} [@Schubert2014] \textcolor{blue}{ and RDOS} [@Tang2017]. \textcolor{blue}{ Both HDoutliers and stray use extreme value theory for outlier detection while both KDEOS and RDOS use kernel density estimates. HDoutliers and stray identify outliers, that is outliers are assigned a binary label as output of these algorithms. KDEOS and RDOS do not identify outliers. Instead, they give an anomaly score which can be used to rank outliers. As the algorithms exhibit differences in their output mechanisms, we employ different methods to compare the performance of these algorithms. To compare the performance of lookout with HDoutliers and stray we use the identified outliers. We use F-measure and the geometric mean of sensitivity and specificity denoted by Gmean, which we discuss below to compare these 3 algorithms. To compare lookout with KDEOS and RDOS we use the outlier scores and utilize the area under the Receiver Operator Characteristic curve denoted by AUC. Furthermore, the evaluation metrics F-measure, Gmean and AUC are suited for imbalanced datasets. For KDEOS and RDOS we use the default parameters. For lookout, HDoutliers and stray we use $\alpha = 0.05$. } The F-measure is defined as 
\begin{equation}\label{eq:fmeasure}
	\text{F-measure} = 2\frac{\text{precision} \times \text{recall}}{\left( \text{precision} + \text{recall} \right) }  ,
\end{equation}
where
\begin{equation}\label{eq:pr}
	\text{precision} = \frac{ \textit{tp} }{\textit{tp} + \textit{fp}}  , \qquad \text{and} \qquad \text{recall} = \frac{\textit{tp}}{\textit{tp} + \textit{fn}}  ,
\end{equation}
where *tp*, *fp* and *fn* denote true positives (predicted = true, actual = true), false positives (predicted = true, actual = false) and false negatives (predicted = false, actual =true) respectively. The F-measure is undefined when both precision and recall are zero, which occurs when the true positives *tp* are zero. This happens when the outlier detection algorithm does not identify any correct outliers. We assign zero to the F-measure in such instances.

Sensitivity and specificity are similar evaluation metrics more frequently used in a medical diagnosis context:
\begin{equation}\label{eq:ss}
	\text{sensitivity} = \frac{ \textit{tp} }{\textit{tp} + \textit{fn}}  , \qquad \text{and} \qquad \text{specificity} = \frac{\textit{tn}}{\textit{tn} + \textit{fp}}  ,
\end{equation}
and
\begin{equation}\label{eq:gmean}
	\text{Gmean} = \sqrt{ \text{sensitivity} \times \text{specificity}}  ,
\end{equation}
where *tn* denotes the true negatives (predicted = false, actual = false). In fact, sensitivity and recall are two different terms denoting the same quantity of interest.

\textcolor{blue}{For all 3 experiments we compute the time taken for each algorithm on a Microsoft Surface Pro 3 laptop, with Intel(R) Core(TM) i5-4300U, 2.50GHz processor. We report the time taken as additional metrics.}

### Experiment 1 {-}

For this experiment we consider two normally distributed samples in $\mathbb{R}^6$; one large and one small starting at the same location with the small sample slowly moving out in each iteration. The set of points belonging to the small sample are considered outliers. We consider 400 points in the bigger sample and 5 in the outlying sample, placed at indices 401--405. The points in the larger sample are distributed in each dimension as $\mathcal{N}(0, 1)$. The outliers differ from the normal points in only one dimension; i.e. they are distributed as $\mathcal{N}\left(2 + (i-1)/2, 0.2 \right)$, where $i$ denotes the iteration. In the first iteration the outliers are distributed as $\mathcal{N}\left(2, 0.2 \right)$ in the first dimension and in the tenth iteration they are distributed as $\mathcal{N}\left(6.5, 0.2 \right)$. Each iteration is repeated 10 times to account for randomness.

```{r ComparisonEx1, fig.cap="Experiment 1 with outliers moving out from the normal distribution in $\\mathbb{R}^6$. Graph on the top left shows the first two dimensions in the last iteration and last repetition.  The graph on the top right shows the performance comparison between lookout, HDoutliers, stray, kdeos and rdos using AUC, Fmeasure and Gmean over 10 repetitions. Fmeasure and Gmean are used for algorithms that identify outliers, while AUC is used for algorithms that rank outliers. In this experiment, stray and HDoutliers gave identical results. The graph on the bottom left shows the time taken for these 5 algorithms. The graph on the bottom right shows the corresponding outlier persistence plot.", out.width="100%", message=FALSE}
set.seed(123)
values <- rep(0, 10)
pp <- 10
hdoutliers_gmean <- hdoutliers_fmeasure <- lookout_fmeasure <- lookout_gmean <-
  stray_gmean <- stray_fmeasure <- matrix(0, nrow = pp, ncol = 10)

lookout_roc <- kdeos_roc <- rdos_roc <- matrix(0, nrow=pp, ncol=10)

hdoutliers_time <- lookout_time <- stray_time <- kdeos_time <- rdos_time <- matrix(0, nrow=pp*10, ncol=5)

for (kk in seq(pp)) {
  X <- bind_cols(
    x2 = rnorm(405),
    x3 = rnorm(405),
    x4 = rnorm(405),
    x5 = rnorm(405),
    x6 = rnorm(405)
  )
  x1_1 <- rnorm(400)
  labs <- c(rep(0, 400), rep(1, 5))

  for (i in seq(10)) {
    x1_2 <- rnorm(5, mean = 2 + (i-1)*0.5, sd = 0.2)
    X <- X %>% mutate(x1 = c(x1_1, x1_2))

    ll <- (kk-1)*10 + i

    # STRAY
    tt <- system.time(strayout <- stray::find_HDoutliers(X, knnsearchtype = "kd_tree", alpha=0.05))
    straylabs <- rep(0, 405)
    straylabs[strayout$outliers] <- 1
    strayoutput <- diff_metrics(labs, straylabs)
    stray_gmean[kk, i] <- strayoutput$gmean
    stray_fmeasure[kk, i] <- strayoutput$fmeasure
    stray_time[ll, ] <- tt

    # LOOKOUT
    tt <- system.time(lookoutobj <- lookout(X, alpha=0.05, unitize = TRUE))
    lookoutlabs <- rep(0, 405)
    lookoutlabs[lookoutobj$outliers[ ,1]] <- 1
    lookoutput <- diff_metrics(labs, lookoutlabs)
    lookout_gmean[kk, i] <- lookoutput$gmean
    lookout_fmeasure[kk, i] <- lookoutput$fmeasure
    lookout_scores <- lookoutobj$outlier_scores
    roc_obj <- roc(labs, lookout_scores, direction="<")
    lookout_roc[kk, i] <- roc_obj$auc
    lookout_time[ll, ] <- tt


    # HDOUTLIERS
    tt <- system.time(hdoutobj <- HDoutliers(X, alpha=0.05))
    hdoutlabs <- rep(0, dim(X)[1])
    hdoutlabs[hdoutobj] <- 1
    hdoutput <- diff_metrics(labs, hdoutlabs)
    hdoutliers_gmean[kk, i] <- hdoutput$gmean
    hdoutliers_fmeasure[kk, i] <- hdoutput$fmeasure
    hdoutliers_time[ll, ] <- tt


    # KDEOS
    tt <- system.time(kdeos_scores <- DDoutlier::KDEOS(X)) # using default parameters
    roc_obj <- roc(labs, kdeos_scores, direction="<")
    kdeos_roc[kk, i] <- roc_obj$auc
    kdeos_time[ll, ] <- tt

    # RDOS
    tt <- system.time(rdos_scores <- DDoutlier::RDOS(X)) # using default parameters
    roc_obj <- roc(labs, rdos_scores, direction="<")
    rdos_roc[kk, i] <- roc_obj$auc
    rdos_time[ll, ] <- tt

  }
}

outnew <- persisting_outliers(X)
g2 <- autoplot(outnew) +
  geom_vline(xintercept = outnew$lookoutbw, linetype = "dashed")

lookobj <- lookout(X, alpha = 0.1)
X2 <- as_tibble(X) %>%
  mutate(strength = pmax(0, (0.1 - lookobj$outlier_probability) / 0.01))
g1 <- ggplot(X2, aes(x1, x2)) +
  geom_point(aes(color = strength)) +
  scale_colour_gradientn(colours = col_pal2) +
  theme_bw() +
  theme(legend.position = "none")

# PLOT F-MEASURE
str_mean <- colMeans(stray_fmeasure)
lookout_mean <- colMeans(lookout_fmeasure)
hdoutliers_mean <- colMeans(hdoutliers_fmeasure)

# Commented these lines as we're putting together the graphs - SK
# df <- tibble(
#     Iteration = seq(10),
#     stray = str_mean,
#     lookout = lookout_mean,
#     HDoutliers = hdoutliers_mean
#   ) %>%
#   pivot_longer(-Iteration, names_to = "Method")
# g3 <- ggplot(df, aes(Iteration, value)) +
#   geom_line(aes(color = Method), size = 1) +
#   ylab("Fmeasure") +
#   theme_bw() +
#   scale_x_continuous(breaks = 1:10) +
#   theme(legend.position = "none")

dfl1 <- tibble(
  Iteration = seq(10),
  stray = str_mean,
  lookout = lookout_mean,
  HDoutliers = hdoutliers_mean
) %>%
  pivot_longer(-Iteration, names_to = "Algorithm") %>%
  mutate(Metric = 'Fmeasure')


# PLOT GEOMETRIC MEAN OF SENSITIVITY AND SPECIFICITY
str_mean <- colMeans(stray_gmean)
lookout_mean <- colMeans(lookout_gmean)
hdoutliers_mean <- colMeans(hdoutliers_gmean)

# df <- tibble(
#     Iteration = seq(10),
#     stray = str_mean,
#     lookout = lookout_mean,
#     HDoutliers = hdoutliers_mean
#   ) %>%
#   pivot_longer(-Iteration, names_to = "Method")
# g4 <- ggplot(df, aes(Iteration, value)) +
#   geom_line(aes(color = Method), size = 1) +
#   ylab("Gmean") +
#   scale_x_continuous(breaks = 1:10) +
#   theme_bw()

dfl2 <- tibble(
  Iteration = seq(10),
  stray = str_mean,
  lookout = lookout_mean,
  HDoutliers = hdoutliers_mean
) %>%
  pivot_longer(-Iteration, names_to = "Algorithm") %>%
  mutate(Metric = 'Gmean')

# AUC FOR KDEOS, RDOS AND LOOKOUT
kdeos_mean <- colMeans(kdeos_roc)
lookout_mean <-  colMeans(lookout_roc)
rdos_mean <-  colMeans(rdos_roc)


dfl3 <- tibble(
  Iteration = seq(10),
  kdeos = kdeos_mean,
  lookout = lookout_mean,
  rdos = rdos_mean
) %>%
  pivot_longer(-Iteration, names_to = "Algorithm") %>%
  mutate(Metric = 'AUC')

dfl <- bind_rows(dfl1, dfl2, dfl3)

g3 <- ggplot(dfl, aes(x=Iteration, y=value)) + geom_line(aes(color=Algorithm), size=1) + ylab("Performance") + facet_wrap(~Metric) + scale_x_continuous(breaks=2*(1:5)) + theme_bw()


# TIME TAKEN

dftime <- tibble(
  Run = seq(100),
  stray = stray_time[ ,3],
  lookout = lookout_time[ ,3],
  HDoutliers = hdoutliers_time[ ,3], 
  kdeos = kdeos_time[ ,3], 
  rdos = rdos_time[ ,3]
) %>%
  pivot_longer(-Run, names_to = "Algorithm")


g4 <- ggplot(dftime, aes(Algorithm, value)) + geom_boxplot(outlier.shape = 20)  + ylab("Time (mins)") + coord_flip() + theme_bw()

(g1 | g3) / (g4 | g2)
```

The top left graph of Figure \ref{fig:ComparisonEx1} shows the first two dimensions of this experimental dataset in its last iteration and repetition with outliers identified by lookout shown in different colors.
\textcolor{blue}{ The top right graph shows the performance comparison of lookout, HDoutliers, stray, KDEOS and RDOS. As lookout, HDoutliers and stray identify outliers, we have used the Fmeasure and Gmean to compare their performance. As KDEOS and RDOS rank outliers instead of identifying them, we have used the AUC -- the area under the ROC curve -- to compare their performance. We see that for each iteration lookout surpasses HDoutliers and stray significantly. Lookout gives much better performance than KDEOS, and from the fourth iteration onwards lookout surpasses RDOS. The graph on the bottom left shows the time taken for each algorithm. We see that RDOS takes a much longer time than the other algorithms. HDoutliers and stray are the fastest, followed by lookout. The graph on the bottom right shows the outlier persistence plot for this data with the dashed line denoting the lookout bandwidth.}
<!-- The top right graph shows the corresponding outlier persistence plot for this data with the dashed line denoting the lookout bandwidth. The graphs at the bottom show the performance of lookout, HDoutliers and stray with $\alpha = 0.05$. The mean F-measure of the 10 repetitions for each iteration is shown in the graph at the bottom left and the mean Gmean is shown at the bottom right. We see that for each iteration lookout surpasses HDoutliers and stray significantly. -->

### Experiment 2 {-}

For this experiment we consider an annulus in $\mathbb{R}^2$ with outlying points moving into the center with each iteration. We consider $800$ points in the annulus with $5$ outlying points. The outliers are normally distributed and have a smaller standard deviation compared to the other points. The mean of the outliers in the $i^{\text{th}}$ iteration is $\left( 5 - (i-1) /2,  0 \right)$, so that the outliers start at the right of the annulus with mean $(5,0)$ and move in with each iteration, ending with mean $(0,0)$. We repeat each iteration 10 times.

```{r ComparisonEx2, fig.cap="Experiment 2 with outliers moving into the center of the annulus in $\\mathbb{R}^2$. Graph on the top left shows the points from the last iteration and repetition. The graph on the top right shows the performance comparison between lookout, HDoutliers, stray, kdeos and rdos using AUC, Fmeasure and Gmean over 10 repetitions. The graph on the bottom left shows the time taken for these 5 algorithms. The graph on the bottom right shows the corresponding outlier persistence plot.", out.width="100%", message=FALSE}
set.seed(1234)
values <- rep(0, 10)
pp <- 10
hdoutliers_gmean <- hdoutliers_fmeasure <- lookout_fmeasure <- lookout_gmean <-
  stray_gmean <- stray_fmeasure <- matrix(0, nrow = pp, ncol = 10)

lookout_roc <- kdeos_roc <- rdos_roc <- matrix(0, nrow=pp, ncol=10)

hdoutliers_time <- lookout_time <- stray_time <- kdeos_time <- rdos_time <- matrix(0, nrow=pp*10, ncol=5)

for (kk in seq(pp)) {
  nn <- 805
  r1 <- runif(nn)
  r2 <- rnorm(nn, mean = 5)
  theta <- 2 * pi * r1
  R2 <- 2
  dist <- r2 + R2
  X <- tibble(
    x1 = dist * cos(theta),
    x2 = dist * sin(theta)
  )
  labs <- c(rep(0, nn-5), rep(1, 5))

  for (i in seq(10)) {
    X[nn - 5 + seq(5), 1] <- rnorm(5, 5 - (i-1)*0.5, sd = 0.1)
    X[nn - 5 + seq(5), 2] <- rnorm(5, 0, sd = 0.1)

    ll <- (kk-1)*10 + i
    # STRAY
    tt <- system.time(strayout <- stray::find_HDoutliers(X, knnsearchtype = "kd_tree", alpha=0.05))
    straylabs <- rep(0, nn)
    straylabs[strayout$outliers] <- 1
    strayoutput <- diff_metrics(labs, straylabs)
    stray_gmean[kk, i] <- strayoutput$gmean
    stray_fmeasure[kk, i] <- strayoutput$fmeasure
    stray_time[ll, ] <- tt


    # LOOKOUT
    tt <- system.time(lookoutobj <- lookout(X, alpha=0.05, unitize = TRUE))
    lookoutlabs <- rep(0, nn)
    lookoutlabs[lookoutobj$outliers[ ,1]] <- 1
    lookoutput <- diff_metrics(labs, lookoutlabs)
    lookout_gmean[kk, i] <- lookoutput$gmean
    lookout_fmeasure[kk, i] <- lookoutput$fmeasure
    lookout_scores <- lookoutobj$outlier_scores
    roc_obj <- roc(labs, lookout_scores, direction="<")
    lookout_roc[kk, i] <- roc_obj$auc
    lookout_time[ll, ] <- tt


    # HDOUTLIERS
    tt <- system.time(hdoutobj <- HDoutliers(X, alpha=0.05))
    hdoutlabs <- rep(0, nn)
    hdoutlabs[hdoutobj] <- 1
    hdoutput <- diff_metrics(labs, hdoutlabs)
    hdoutliers_gmean[kk, i] <- hdoutput$gmean
    hdoutliers_fmeasure[kk, i] <- hdoutput$fmeasure
    hdoutliers_time[ll, ] <- tt

    # KDEOS
    tt <- system.time(kdeos_scores <- DDoutlier::KDEOS(X)) # using default parameters
    roc_obj <- roc(labs, kdeos_scores, direction="<")
    kdeos_roc[kk, i] <- roc_obj$auc
    kdeos_time[ll, ] <- tt

    # RDOS
    tt <- system.time(rdos_scores <- DDoutlier::RDOS(X)) # using default parameters
    roc_obj <- roc(labs, rdos_scores, direction="<")
    rdos_roc[kk, i] <- roc_obj$auc
    rdos_time[ll, ] <- tt

  }
}

outnew <- persisting_outliers(X)
g2 <- autoplot(outnew) + geom_vline(xintercept = outnew$lookoutbw, linetype = "dashed")

lookobj <- lookout(X, alpha = 0.1)
strength <- (0.1 - lookobj$outlier_probability) / 0.01
strength[strength < 0] <- 0

X2 <- cbind.data.frame(X, strength)
g1 <- ggplot(X2, aes(x1, x2)) +
  geom_point(aes(color = strength)) +
  scale_colour_gradientn(colours = col_pal2) +
  theme_bw() +
  theme(legend.position = "none")

# F-MEASURE
str_mean <- colMeans(stray_fmeasure)
lookout_mean <- colMeans(lookout_fmeasure)
hdoutliers_mean <- colMeans(hdoutliers_fmeasure)


dfl1 <- tibble(
  Iteration = seq(10),
  stray = str_mean,
  lookout = lookout_mean,
  HDoutliers = hdoutliers_mean
) %>%
  pivot_longer(-Iteration, names_to = "Algorithm") %>%
  mutate(Metric = 'Fmeasure')


# GEOMETRIC MEAN OF SENSITIVITY AND SPECIFICITY
str_mean <- colMeans(stray_gmean)
lookout_mean <- colMeans(lookout_gmean)
hdoutliers_mean <- colMeans(hdoutliers_gmean)


dfl2 <- tibble(
  Iteration = seq(10),
  stray = str_mean,
  lookout = lookout_mean,
  HDoutliers = hdoutliers_mean
) %>%
  pivot_longer(-Iteration, names_to = "Algorithm") %>%
  mutate(Metric = 'Gmean')

# AUC FOR KDEOS, RDOS AND LOOKOUT
kdeos_mean <- colMeans(kdeos_roc)
lookout_mean <-  colMeans(lookout_roc)
rdos_mean <-  colMeans(rdos_roc)


dfl3 <- tibble(
  Iteration = seq(10),
  kdeos = kdeos_mean,
  lookout = lookout_mean,
  rdos = rdos_mean
) %>%
  pivot_longer(-Iteration, names_to = "Algorithm") %>%
  mutate(Metric = 'AUC')

dfl <- bind_rows(dfl1, dfl2, dfl3)

g3 <- ggplot(dfl, aes(x=Iteration, y=value)) + geom_line(aes(color=Algorithm), size=1) + ylab("Performance") + facet_wrap(~Metric) + scale_x_continuous(breaks=2*(1:5)) + theme_bw()


# TIME TAKEN
dftime <- tibble(
  Run = seq(100),
  stray = stray_time[ ,3],
  lookout = lookout_time[ ,3],
  HDoutliers = hdoutliers_time[ ,3],
  kdeos = kdeos_time[ ,3],
  rdos = rdos_time[ ,3]
) %>%
  pivot_longer(-Run, names_to = "Algorithm")


g4 <- ggplot(dftime, aes(Algorithm, value)) + geom_boxplot(outlier.shape = 20)  + ylab("Time (mins)") + coord_flip() + theme_bw()

(g1 | g3) / (g4 | g2)
```

The graph at the top left of Figure \ref{fig:ComparisonEx2} shows the points in the final iteration and repetition. \textcolor{blue}{ The graph at the top right shows the performance comparison using AUC, F-measure and Gmean. We see that lookout performs better than the other algorithms across different metrics. The graph on the bottom left shows the time taken for each algorithm. RDOS takes much longer compared to others, while HDoutliers and stray are the fastest followed by lookout.} The graph on the bottom right shows the outlier persistence for the final iteration and repetition. The outliers are placed at indices 801--805 and we see that they are not identified as outliers for small bandwidth values because the outliers are clustered together. This shows the importance of bandwidth selection for outlier detection when using kernel density estimates. The bandwidth selected by lookout is shown as a dashed line.

<!-- The graph on the top right shows the outlier persistence for the final iteration and repetition. The outliers are placed at indices 801--805 and we see that they are not identified as outliers for small bandwidth values because the outliers are clustered together. This shows the importance of bandwidth selection for outlier detection when using kernel density estimates. The bandwidth selected by lookout is shown as a dashed line. The bottom two graphs show the mean F-measure and Gmean of the 3 algorithms for each iteration over 10 repetitions. We see that lookout identifies the outliers earlier than stray while HDoutliers does not identify any outliers. -->

### Experiment 3 {-}

For this experiment we consider a unit cube in $\mathbb{R}^{20}$ with 500 points, of which 499 points are uniformly distributed in each direction and the remaining point is an outlier. The outlier moves towards the point $\left( 0.9, 0.9, \dots, 0.9 \right)$ with each iteration. For the $i^{\text{th}}$ iteration the first $i$ coordinates of the outlier are each equal to $0.9$ and the remaining coordinates are uniformly distributed in $(0,1)$. The index of the outlier is 500. Each iteration is repeated 10 times with different randomizations.

```{r ComparisonEx3, fig.cap="Experiment 3 with an outlier moving to $(0.9, 0.9, \\dots)$. Graph on the top shows the performance comparison between lookout, HDoutliers, stray, KDEOS and RDOS using AUC, Fmeasure and Gmean over 10 repetitions. The graph on the bottom left shows the time taken for these 5 algorithms. The graph on the bottom right shows the corresponding outlier persistence plot.", out.width="100%", message=FALSE}

values <- rep(0, 10)
pp <- 10
dd <- 19
hdoutliers_gmean <- hdoutliers_fmeasure <- lookout_fmeasure <- lookout_gmean <-
  stray_gmean <- stray_fmeasure <- matrix(0, nrow = pp, ncol = 20)

lookout_roc <- kdeos_roc <- rdos_roc <- matrix(0, nrow=pp, ncol=20)

hdoutliers_time <- lookout_time <- stray_time <- kdeos_time <- rdos_time <- matrix(0, nrow=pp*20, ncol=5)

set.seed(123)
nn <- 500
labs <- c(rep(0, nn-1), 1)

for (kk in seq(pp)) {
  X <- matrix(runif(nn*(dd+1)), ncol=dd+1, nrow=nn)
  colnames(X) <- paste("x", 1:20, sep = "")

  for (i in seq(20)) {
    X[nn, seq(i)] <- rep(0.9, i)

     ll <- (kk-1)*10 + i
     # STRAY
    tt <- system.time(strayout <- stray::find_HDoutliers(X, knnsearchtype = "kd_tree", alpha=0.05))
    straylabs <- rep(0, nn)
    straylabs[strayout$outliers] <- 1
    strayoutput <- diff_metrics(labs, straylabs)
    stray_gmean[kk, i] <- strayoutput$gmean
    stray_fmeasure[kk, i] <- strayoutput$fmeasure
    stray_time[ll, ] <- tt


    # LOOKOUT
    tt <- system.time(lookoutobj <- lookout(X, alpha=0.05, unitize = TRUE))
    lookoutlabs <- rep(0, nn)
    lookoutlabs[lookoutobj$outliers[ ,1]] <- 1
    lookoutput <- diff_metrics(labs, lookoutlabs)
    lookout_gmean[kk, i] <- lookoutput$gmean
    lookout_fmeasure[kk, i] <- lookoutput$fmeasure
    lookout_scores <- lookoutobj$outlier_scores
    roc_obj <- roc(labs, lookout_scores, direction="<")
    lookout_roc[kk, i] <- roc_obj$auc
    lookout_time[ll, ] <- tt


    # HDOUTLIERS
    tt <- system.time(hdoutobj <- HDoutliers(X, alpha=0.05))
    hdoutlabs <- rep(0, nn)
    hdoutlabs[hdoutobj] <- 1
    hdoutput <- diff_metrics(labs, hdoutlabs)
    hdoutliers_gmean[kk, i] <- hdoutput$gmean
    hdoutliers_fmeasure[kk, i] <- hdoutput$fmeasure
    hdoutliers_time[ll, ] <- tt

    # KDEOS
    tt <- system.time(kdeos_scores <- DDoutlier::KDEOS(X)) # using default parameters
    roc_obj <- roc(labs, kdeos_scores, direction="<")
    kdeos_roc[kk, i] <- roc_obj$auc
    kdeos_time[ll, ] <- tt

    # RDOS
    tt <- system.time(rdos_scores <- DDoutlier::RDOS(X)) # using default parameters
    roc_obj <- roc(labs, rdos_scores, direction="<")
    rdos_roc[kk, i] <- roc_obj$auc
    rdos_time[ll, ] <- tt
  }
}

outnew <- persisting_outliers(X)
g2 <- autoplot(outnew) +
  geom_vline(xintercept = outnew$lookoutbw, linetype = "dashed")

# F-MEASURE
str_mean <- colMeans(stray_fmeasure)
lookout_mean <- colMeans(lookout_fmeasure)
hdoutliers_mean <- colMeans(hdoutliers_fmeasure)


dfl1 <- tibble(
  Iteration = seq(20),
  stray = str_mean,
  lookout = lookout_mean,
  HDoutliers = hdoutliers_mean
) %>%
  pivot_longer(-Iteration, names_to = "Algorithm") %>%
  mutate(Metric = 'Fmeasure')


# GEOMETRIC MEAN OF SENSITIVITY AND SPECIFICITY
str_mean <- colMeans(stray_gmean)
lookout_mean <- colMeans(lookout_gmean)
hdoutliers_mean <- colMeans(hdoutliers_gmean)


dfl2 <- tibble(
  Iteration = seq(20),
  stray = str_mean,
  lookout = lookout_mean,
  HDoutliers = hdoutliers_mean
) %>%
  pivot_longer(-Iteration, names_to = "Algorithm") %>%
  mutate(Metric = 'Gmean')

# AUC FOR KDEOS, RDOS AND LOOKOUT
kdeos_mean <- colMeans(kdeos_roc)
lookout_mean <-  colMeans(lookout_roc)
rdos_mean <-  colMeans(rdos_roc)


dfl3 <- tibble(
  Iteration = seq(20),
  kdeos = kdeos_mean,
  lookout = lookout_mean,
  rdos = rdos_mean
) %>%
  pivot_longer(-Iteration, names_to = "Algorithm") %>%
  mutate(Metric = 'AUC')

dfl <- bind_rows(dfl1, dfl2, dfl3)

g3 <- ggplot(dfl, aes(x=Iteration, y=value)) + geom_line(aes(color=Algorithm), size=1) + ylab("Performance") + facet_wrap(~Metric) + scale_x_continuous(breaks=2*(1:10)) + theme_bw()


# TIME TAKEN
dftime <- tibble(
  Run = seq(200),
  stray = stray_time[ ,3],
  lookout = lookout_time[ ,3],
  HDoutliers = hdoutliers_time[ ,3],
  kdeos = kdeos_time[ ,3],
  rdos = rdos_time[ ,3]
) %>%
  pivot_longer(-Run, names_to = "Algorithm")


g4 <- ggplot(dftime, aes(Algorithm, value)) + geom_boxplot(outlier.shape = 20)  + ylab("Time (mins)") + coord_flip() + theme_bw()


g3 / (g4 | g2)
```

 \textcolor{blue}{The top graph in Figure \ref{fig:ComparisonEx3} shows the performance comparison between the different algorithms. We see that RDOS performs better than lookout in the initial 8 iterations of this experiment. After the $8^{\text{th}}$ iteration lookout performs better than RDOS. We also see that lookout performs significantly better than stray and HDoutliers. The graph on the bottom left shows the time taken for the 5 algorithms. Stray is the fastest followed by HDoutliers. The slowest algorithm is RDOS. The graph in the bottom right }  shows the outlier persistence for the last iteration and repetition. The dashed line shows the bandwidth chosen by lookout.

<!-- The top graph in Figure \ref{fig:ComparisonEx3} shows the outlier persistence for the last iteration and repetition. The dashed line shows the bandwidth chosen by lookout. -->

<!-- The two graphs at the bottom show the comparison with HDoutliers and stray for each iteration averaged over the repetitions. We see that HDoutliers and stray do not identify the outlier for 19 of the 20 iterations. Lookout clearly gives better performance and achieves an average Gmean of 0.999 from the $16^{\text{th}}$ iteration onward. -->



### \textcolor{blue}{Comparison of false positives } {-}
\textcolor{blue}{
A low false positive rate is an attractive feature for an outlier detection method. High false positives diminish user confidence with the risk of abandonment of such systems; consider a home security system with constant alarms. To get an understanding of the false positives, we redo experiments 1-3 without any outliers and compare the specificity ($tn/(tn+fp)$) of HDoutliers, stray and lookout. We repeat each experiment 10 times. As KDEOS and RDOS do not identify outliers, we do not include them in this comparison. High values of specificity is preferred as low values indicate more false positives. Table \ref{tab:zerooutliers} shows the specificity comparison results. Stray has the highest, average specificity of 1 with zero standard deviation;  HDoutliers has a similar specificity for all three experiments. We see that the average specificity of lookout is greater than $0.99$ with low standard deviation values. Thus lookout's specificity is comparable to HDoutliers and stray, demonstrating that its false positive rate is low. }

```{r zerooutliers, fig.cap="", out.width="100%", message=FALSE}

output <- matrix(0, nrow=3, ncol=6)
colnames(output) <- c("lookout_mean", "lookout_sd", "stray_mean", "stray_sd", "hdoutliers_mean", "hdoutliers_sd")

# ---------------------------------------------------------------------
# TASK 1 - EXAMPLE 1 - NO OUTLIERS
# ---------------------------------------------------------------------
library(lookout)
library(HDoutliers)
library(stray)
values <- rep(0, 10)
pp <- 10

hdoutliers_specificity <- stray_specificity <- lookout_specificity <-  rep(0, 10)


set.seed(123)
for(kk in 1:pp){
  x2 <- rnorm(405)
  x3 <- rnorm(405)
  x4 <- rnorm(405)
  x5 <- rnorm(405)
  x6 <- rnorm(405)
  x1 <- rnorm(405)

  X <- cbind(x1,x2,x3,x4,x5,x6)
  labs <- rep(0,405)

  # STRAY
  strayout <- stray::find_HDoutliers(X, knnsearchtype = "kd_tree", alpha=0.05)
  straylabs <- rep(0, 405)
  straylabs[strayout$outliers] <- 1
  strayoutput <- diff_metrics_2(labs, straylabs)
  stray_specificity[kk] <- strayoutput$specificity



  # LOOKOUT
  lookoutobj <- lookout(X, alpha=0.05, unitize = TRUE)
  lookoutlabs <- rep(0, 405)
  lookoutlabs[lookoutobj$outliers[ ,1]] <- 1
  lookoutput <- diff_metrics_2(labs, lookoutlabs)
  lookout_specificity[kk] <- lookoutput$specificity



  # HDOUTLIERS
  hdoutobj <- HDoutliers(X, alpha=0.05)
  hdoutlabs <- rep(0, dim(X)[1])
  hdoutlabs[hdoutobj] <- 1
  hdoutput <- diff_metrics_2(labs, hdoutlabs)
  hdoutliers_specificity[kk] <- hdoutput$specificity

}
output[1, ] <- c(mean(lookout_specificity), sd(lookout_specificity), mean(stray_specificity), sd(stray_specificity), mean(hdoutliers_specificity), sd(hdoutliers_specificity))

# ---------------------------------------------------------------------
# TASK 2 - EXAMPLE 2 - NO OUTLIERS
# ---------------------------------------------------------------------
hdoutliers_specificity <- stray_specificity <- lookout_specificity <-  rep(0, 10)

set.seed(1234)
for(kk in 1:pp){
  r1 <-runif(805)
  r2 <-rnorm(805, mean=5)
  theta = 2*pi*r1;
  R1 <- 2
  R2 <- 2
  dist = r2+R2;
  x =  dist * cos(theta)
  y =  dist * sin(theta)

  X <- data.frame(
    x1 = x,
    x2 = y
  )
  labs <- rep(0,805)

  # STRAY
  strayout <- stray::find_HDoutliers(X, knnsearchtype = "kd_tree", alpha=0.05)
  straylabs <- rep(0, 805)
  straylabs[strayout$outliers] <- 1
  strayoutput <- diff_metrics_2(labs, straylabs)
  stray_specificity[kk] <- strayoutput$specificity



  # LOOKOUT
  lookoutobj <- lookout(X, alpha=0.05, unitize = TRUE)
  lookoutlabs <- rep(0, 805)
  lookoutlabs[lookoutobj$outliers[ ,1]] <- 1
  lookoutput <- diff_metrics_2(labs, lookoutlabs)
  lookout_specificity[kk] <- lookoutput$specificity



  # HDOUTLIERS
  hdoutobj <- HDoutliers(X, alpha=0.05)
  hdoutlabs <- rep(0, dim(X)[1])
  hdoutlabs[hdoutobj] <- 1
  hdoutput <- diff_metrics_2(labs, hdoutlabs)
  hdoutliers_specificity[kk] <- hdoutput$specificity

}
output[2, ] <- c(mean(lookout_specificity), sd(lookout_specificity), mean(stray_specificity), sd(stray_specificity), mean(hdoutliers_specificity), sd(hdoutliers_specificity))


# ---------------------------------------------------------------------
# TASK 3 - EXAMPLE 3 - NO OUTLIERS
# ---------------------------------------------------------------------

hdoutliers_specificity <- stray_specificity <- lookout_specificity <-  rep(0, 10)

labs <- rep(0, 500)
set.seed(123)
for(kk in 1:pp){
  X <- runif(500)
  for(j in 1:19){
    X <- cbind(X, runif(500))
  }
  colnames(X) <- paste("x", 1:20, sep="")
  # STRAY
  strayout <- stray::find_HDoutliers(X, knnsearchtype = "kd_tree", alpha=0.05)
  straylabs <- rep(0, 500)
  straylabs[strayout$outliers] <- 1
  strayoutput <- diff_metrics_2(labs, straylabs)
  stray_specificity[kk] <- strayoutput$specificity



  # LOOKOUT
  lookoutobj <- lookout(X, alpha=0.05, unitize = TRUE)
  lookoutlabs <- rep(0, 500)
  lookoutlabs[lookoutobj$outliers[ ,1]] <- 1
  lookoutput <- diff_metrics_2(labs, lookoutlabs)
  lookout_specificity[kk] <- lookoutput$specificity



  # HDOUTLIERS
  hdoutobj <- HDoutliers(X, alpha=0.05)
  hdoutlabs <- rep(0, dim(X)[1])
  hdoutlabs[hdoutobj] <- 1
  hdoutput <- diff_metrics_2(labs, hdoutlabs)
  hdoutliers_specificity[kk] <- hdoutput$specificity

}
output[3, ] <- c(mean(lookout_specificity), sd(lookout_specificity), mean(stray_specificity), sd(stray_specificity), mean(hdoutliers_specificity), sd(hdoutliers_specificity))

output <- round(as.data.frame(output), 4)

headcols <- data.frame(c1 = c("", "lookout", "stray", "HDoutliers"), c2=c(1, 2, 2, 2))

output %>%
  mutate(experiment = seq(3)) %>% relocate(experiment, .before = lookout_mean ) %>%
  knitr::kable(
    col.names = c("Experiment", "mean","sd", "mean", "sd", "mean", "sd"),
    booktabs = TRUE,
    caption = "Specificity for lookout, HDoutliers and stray algorithms when no outliers are present.") %>% kableExtra::add_header_above(x, header=headcols) %>%  kableExtra::row_spec(1:dim(output)[1], color = "blue")
```

## \textcolor{blue}{Evaluating time series outliers }{-}
\textcolor{blue}{
In this section we compare the time series implementation of lookout with the outlier detection method proposed by } @Burridge2006, \textcolor{blue}{which we denote by BT. For this example we simulate an ARIMA$(1, 1, 0)$ time series with the autoregressive parameter taking values $0.5, 0.6, 0.7, 0.8$ and $0.9$. We add an outlier to each simulated time series and repeat the simulation 10 times for each parameter value to account for randomness. Table \ref{tab:timeseriesdatviz} gives the results of lookout and BT using Gmean and Fmeasure. We see that lookout gives better performance than BT for all parameter values. 
}

```{r timeseriesdat, echo=FALSE, include=FALSE}
lookout_ts <- function(x, alpha = 0.1){
  u <- c(0,diff(diff(x)))
  out <- lookout(u, alpha = alpha, unitize = FALSE, bw = NULL, gpd = NULL)

  outliers <- out$outliers[ ,1]

  if(length(outliers) > 1){
   oo <- c()
   clust <- cumsum(c(1, diff(outliers) > 1))
   len <- max(clust)
   for(kk in 1:len){
     inds <- outliers[which(clust==kk)]
     oo <- c(oo, inds[which.min(out$outlier_probability[inds])] )
   }
   inds <- which(out$outliers[ ,1] %in% oo)
   out$outliers <- out$outliers[inds, ]
  }
  out
}


BT_outliers <- function(X, alpha=0.05, k=1){
  out <- c()
  for(i in 1:k){
    df1 <- diff(X)
    df2 <- -diff(X)
    df3 <- abs(df2)
    ordstatx <- sort(df3, decreasing = TRUE)
    ordx <- order(df3, decreasing = TRUE)

    BT_weights <- c(1, 0.531, 0.362, 0.280, 0.230, 0.193, 0.169, 0.147, 0.132, 0.123, 0.113, 0.104, 0.096, 0.088, 0.083, 0.080, 0.075, 0.071, 0.067, 0.065, 0.062, 0.060, 0.058, 0.056, 0.053, 0.052, 0.050, 0.048, 0.047, 0.046, 0.044, 0.042, 0.042, 0.040, 0.040, 0.039, 0.037, 0.037, 0.036, 0.035, 0.035, 0.034, 0.033, 0.032, 0.032, 0.031, 0.031, 0.031, 0.030, 0.029, 0.028, 0.028, 0.027, 0.027, 0.027, 0.026, 0.026, 0.025, 0.025, 0.025, 0.024, 0.024, 0.023, 0.023, 0.023, 0.023, 0.022, 0.022, 0.022, 0.022, 0.021, 0.021, 0.020, 0.020, 0.020, 0.020, 0.020, 0.020, 0.019, 0.019, 0.019, 0.019, 0.019, 0.018, 0.018, 0.018, 0.018, 0.018, 0.018, 0.018, 0.017, 0.017, 0.017, 0.017, 0.016, 0.016, 0.016, 0.016, 0.016, 0.016, 0.016, 0.015, 0.015, 0.015, 0.015, 0.015, 0.015, 0.015, 0.015, 0.015, 0.015, 0.014, 0.014, 0.014, 0.014, 0.014, 0.014, 0.014, 0.013, 0.013)

    ll <- 3*k/alpha
    y <- -1*diff(ordstatx)[1:120]/BT_weights

    set1 <- 1:(3*k)
    cond <- which.max(y[1:(3*k/alpha)]) %in% set1
    if(!cond){
      return(out)
    }else{
      out <- c(out, ordx[which.max(y[1:(3*k/alpha)])] )
      X[out] <- X[out] - df2[out]

    }
  }
  return(out)
}


set.seed(1)
BT_gmean <- BT_fmeasure <- lookout_gmean  <- lookout_fmeasure <- matrix(0, nrow = 10, ncol = 5)
for(ii in 1:5){
  ar_val = 0.4 + ii*0.1
  for(jj in 1:10){
    ts_sim <- arima.sim(list(order = c(1,1,0), ar = ar_val), n = 200)
    ts_sim[50] <- ts_sim[50]  + 10
    labs <- rep(0, 200)
    labs[50] <- 1

    btout <- BT_outliers(ts_sim, k=3, alpha=0.1)
    loutobj <- lookout_ts(ts_sim, alpha=0.1)

    btlabs <- rep(0, 200)
    btlabs[btout] <- 1

    looklabs <- rep(0, 200)
    looklabs[loutobj$outliers[ ,1]] <- 1

    dm_bt <- diff_metrics(labs, btlabs)
    dm_lo <- diff_metrics(labs, looklabs)

    BT_gmean[jj, ii] <- dm_bt$gmean
    BT_fmeasure[jj, ii] <- dm_bt$fmeasure
    lookout_gmean[jj, ii] <- dm_lo$gmean
    lookout_fmeasure[jj, ii] <- dm_lo$fmeasure
  }
}
```

```{r timeseriesdatviz, dependson="timeseriesdat", fig.cap="", out.width="100%", message=FALSE, echo=FALSE}
look_gm_mean <- apply(lookout_gmean, 2, mean)
look_gm_sd <- apply(lookout_gmean, 2, sd)
look_fm_mean <- apply(lookout_fmeasure, 2, mean)
look_fm_sd <- apply(lookout_fmeasure, 2, sd)

BT_gm_mean <- apply(BT_gmean, 2, mean)
BT_gm_sd <- apply(BT_gmean, 2, sd)
BT_fm_mean <- apply(BT_fmeasure, 2, mean)
BT_fm_sd <- apply(BT_fmeasure, 2, sd)

output <- tibble(ar = 0.1*(5:9),   lookout_gmean_m = look_gm_mean, lookout_gmean_sd = look_gm_sd,   BT_gmean_m = BT_gm_mean, BT_gmean_sd =  BT_gm_sd, look_fmeasure_m = look_fm_mean, look_fmeasure_sd = look_fm_sd, BT_fmeasure_m = BT_fm_mean, BT_fmeasure_sd = BT_fm_sd  )
output <- round(output, 3)

headcols <- data.frame(c1 = c("", "Gmean", "FMeasure"), c2=c(1, 4, 4))
headcols2 <- data.frame(c1 = c("", "lookout", "BT", "lookout", "BT"), c2=c(1, 2, 2, 2, 2))
# output %>%
#   knitr::kable(
#     col.names = c("AR", "lookout mean", "lookout sd", "BT mean", "BT sd", "lookout mean", "lookout sd", "BT mean", "BT sd"),
#     booktabs = TRUE,
#     caption = "Time series outliers performance comparison") %>% kableExtra::add_header_above(x, header=headcols) %>%  kableExtra::row_spec(1:dim(output)[1], color = "blue")

output %>%
  knitr::kable(
    col.names = c("AR", "mean", "sd", "mean", "sd", "mean", "sd", "mean", "sd"),
    booktabs = TRUE,
    caption = "Time series outliers performance comparison") %>% kableExtra::add_header_above(x, header=headcols2) %>% kableExtra::add_header_above(x, header=headcols) %>%  kableExtra::row_spec(1:dim(output)[1], color = "blue")


```

# Results on two data repositories {#sec:applications}

For this section we use \textcolor{blue}{two data repositories: the ODDS data repository} [@datasetsODDS] \textcolor{blue}{and the repository at} @datasets. \textcolor{blue}{Using the ODDS repository, we will look at the individual performance of 12 well known datasets to these 5 outlier detection methods. As} @datasets \textcolor{blue}{ has more than $12000$ outlier detection datasets, we will evaluate the performance of these methods on the repository and report summary statistics because the number of datasets is large. }

## ODDS data repository

<!-- We use the two repositories in slightly different ways. We use 12 datasets from the ODDS repository and evaluate the performance of the 5 outlier detection methods on these datasets. We report the individual performance of each method on each dataset.}  -->
<!-- @datasets has more than $12000$ outlier detection datasets that were prepared from classification datasets.  \textcolor{blue}{ We evaluate the performance of these 5 outlier detection methods on this data repository. While lookout, HDoutliers and stray gave valid output for all 12000+ datasets, RDOS and KDEOS gave errors for 5745 datasets. As such, we only compare lookout, stray and HDoutliers on this data repository. We report the summary statistics as the number of datasets is large.}   -->

<!-- Dataset preparation involves downsampling the minority class in classification datasets, converting the categorical variables to numerical and accounting for missing values, all of which is detailed in @normalizationoutliers. -->

```{r ODDSdatasetswork, message=FALSE, echo=FALSE, results='hide', warning=FALSE, fig.show='hide', include=FALSE }
knitr::knit_hooks$set(
  evaluate.inline = function (code, envir = knit_global()) {
    v = try(eval(xfun::parse_only(code), envir = envir))
    knitr::knit_print(v, inline = TRUE, options = knitr::opts_chunk$get())
  },
  inline = function(x) {
  if (any(class(x) == "try-error")) {
    as.vector(x)
  } else x
})


folder <- "Data_Input/"

output <- data.frame(look_gmean = numeric(), stray_gmean = numeric(), hdout_gmean = numeric(), look_fmeas = numeric(), stray_fmeas = numeric(),  hdout_fmeas = numeric(), look_roc = numeric(), kdeos_roc = numeric(), rdos_roc = numeric())

file_list <- list.files(folder)

for(i in 1:length(file_list)){ 
  dat <- readMat(paste(folder, file_list[i], sep=""))

  # lookout
  lookobj <- lookout::lookout(dat$X, alpha=0.1)
  look_scores <- lookobj$outlier_scores
  lookoutlabs <- rep(0, dim(dat$X)[1])
  lookoutlabs[lookobj$outliers[ ,1]] <- 1
  lookoutput <- diff_metrics(dat$y[ ,1], lookoutlabs)
  lookrocobj <- roc(dat$y[ ,1], look_scores, direction="<" )
  nn <- dim(dat$X)[1]

  # KDEOS
  kdeos_scores <- tryCatch(DDoutlier::KDEOS(dat$X), error = function(e){
    print(sys.calls())
    kdeos_scores <- rep(NA, nn)
    return(kdeos_scores)})
  kdeosroc_obj <- tryCatch(roc(dat$y[ ,1], kdeos_scores, direction="<"), error = function(e){
    print(sys.calls())
    kdeosroc_obj <- list()
    kdeosroc_obj$auc <- NA
    return(kdeosroc_obj)})
  kdeos_roc <- kdeosroc_obj$auc

  # RDOS
  rdos_scores <- tryCatch(DDoutlier::RDOS(dat$X), error = function(e){
    print(sys.calls())
    rdos_scores <- rep(NA, nn)
    return(rdos_scores)})
  rdosroc_obj <- tryCatch(roc(dat$y[ ,1], rdos_scores, direction="<"), error = function(e){
    print(sys.calls())
    rdosroc_obj <- list()
    rdosroc_obj$auc <- NA
    return(rdosroc_obj)})
  rdos_roc <- rdosroc_obj$auc

  # stray
  strayout <- stray::find_HDoutliers(dat$X, knnsearchtype = "kd_tree", alpha=0.1)
  straylabs <- rep(0, dim(dat$X)[1])
  straylabs[strayout$outliers] <- 1
  strayoutput <- diff_metrics(dat$y[ ,1], straylabs)

  # HDOUTLIERS
  hdoutobj <- HDoutliers(dat$X, alpha=0.1)
  hdoutlabs <- rep(0, dim(dat$X)[1])
  hdoutlabs[hdoutobj] <- 1
  hdoutput <- diff_metrics(dat$y[ ,1], hdoutlabs)

  output[i, ] <- c(lookoutput$gmean, strayoutput$gmean, hdoutput$gmean, lookoutput$fmeasure, strayoutput$fmeasure, hdoutput$fmeasure, lookrocobj$auc, kdeos_roc, rdos_roc)

}
```

\textcolor{blue}{Table \ref{tab:ODDResults} shows the results of lookout, HDoutliers, stray, KDEOS and RDOS on  12 ODDS datasets. As previously, we have used F-measure and Gmean to compare the performance of lookout,  HDoutliers and stray, and AUC to compare lookout, KDEOS and RDOS. We see that for datasets glass, optdigits and wine, none of the 3 algorithms lookout, HDoutliers and stray identify any outliers. As such, the Gmean and F-measure are zero for these three datasets.  For the other 9 datasets lookout outperforms stray and HDoutliers.  }

\textcolor{blue}{The AUC values in Table \ref{tab:ODDResults} show that lookout gives the best performance for 8 of the 12 datasets. For the speech dataset lookout is tied with RDOS. RDOS gives the best performance for 3 datasets. Two datasets give errors for KDEOS.
}

```{r ODDResults, dependson="ODDSdatasetswork",  fig.cap="", out.width="100%", message=FALSE, echo=FALSE}
output <- cbind.data.frame(file_list, output)
output[ ,2:dim(output)[2]] <- round(output[ ,2:dim(output)[2]], 2)
output[ ,1] <- substring(output[ ,1], 1, nchar(output[ ,1])-4)

headcols <- data.frame(c1 = c("", "Gmean", "FMeasure", "AUC"), c2=c(1, 3, 3, 3))


output %>%
   knitr::kable(
    col.names = c("Filename", "lookout", "stray", "HDoutliers", "lookout", "stray", "HDoutliers", "lookout", "KDEOS", "RDOS"),
    booktabs = TRUE,
    caption = "Performance evaluation of 12 datasets in the ODDS repository.") %>% kableExtra::add_header_above(x, header=headcols) %>%  kableExtra::row_spec(1:dim(output)[1], color = "blue")

```

## A large data repository

The repository at @datasets has more than $12000$ outlier detection datasets that were prepared from classification datasets. Dataset preparation involves downsampling the minority class in classification datasets, converting the categorical variables to numerical and accounting for missing values, all of which is detailed in @normalizationoutliers. 

\textcolor{blue}{ We evaluate the performance of these 5 outlier detection methods on this data repository. While lookout, HDoutliers and stray gave valid output for all 12000+ datasets, RDOS and KDEOS gave errors for 5745 datasets. As such, we only compare lookout, stray and HDoutliers on this data repository.}

```{r lvplots, fig.cap="Letter value plots of performance differences between 1. lookout and HDoutliers, 2. lookout and stray using Gmean and Fmeasure.", fig.height=4, message=FALSE, out.width="100%"}
dat <- readr::read_csv(here::here("data_repo_output/Collated_EX2_Take1_1_alpha_point05.csv"))

# Differences - gmean
sensitivity <- select(dat, contains("sensitivity"))
specificity <- select(dat, contains("specificity"))
gmean <- sqrt(sensitivity * specificity) %>%
  rename_all(function(x){stringr::str_extract(x, "[a-z]*")}) %>%
  as_tibble() %>%
  bind_cols(dat) %>%
  filter(lookout > 0 | hdoutliers > 0 | stray > 0) %>%
  mutate(
    look_hd = lookout - hdoutliers,
    look_stray = lookout - stray,
  ) %>%
  pivot_longer(look_hd:look_stray, names_to = "Algorithm", values_to = "Gmean")
g1 <- ggplot(gmean, aes(x = Algorithm, y = Gmean)) +
  lvplot::geom_lv(aes(fill = ..LV..),
                  width.method = "area", width = 0.3, show.legend=FALSE) +
  lvplot::scale_fill_lv() +
  labs(x = "Algorithm", y = "Gmean")

# Precision and recall
true_pos <- select(dat, contains("true_pos"))
false_pos <- select(dat, contains("false_pos"))
false_neg <- select(dat, contains("false_neg"))
precision <- as_tibble(true_pos / (true_pos + false_pos)) %>%
  rename_all(function(x){stringr::str_extract(x, "[a-z]*")}) %>%
  replace_na(list(lookout = 0, hdoutliers = 0, stray = 0))
recall <- as_tibble(true_pos / (true_pos + false_neg)) %>%
  rename_all(function(x){stringr::str_extract(x, "[a-z]*")})
fmeas <- as_tibble(2 * precision * recall / (precision + recall)) %>%
  replace_na(list(lookout = 0, hdoutliers = 0, stray = 0)) %>%
  bind_cols(dat) %>%
  filter(lookout > 0 | hdoutliers > 0 | stray > 0) %>%
  mutate(
    look_hd = lookout - hdoutliers,
    look_stray = lookout - stray,
  ) %>%
  pivot_longer(look_hd:look_stray, names_to = "Algorithm", values_to = "Fmeasure")

g2 <- ggplot(fmeas, aes(x = Algorithm, y = Fmeasure)) +
  lvplot::geom_lv(aes(fill = ..LV..), width.method = "area", width = 0.2) +
  lvplot::scale_fill_lv() +
  labs(x = "Algorithm", y = "F measure")

g1 | g2
```

Figure \ref{fig:lvplots} shows the letter-value plots [@lvplots] of performance differences between
(a) lookout and HDoutliers and
(b) lookout and stray,
using Gmean and Fmeasure after removing the entries that have zero values for all three algorithms. Letter-value plots enhance traditional box-plots by including more detailed information making them suitable for large datasets. The letter-value plots in Figure \ref{fig:lvplots} are area adjusted, that is, the area of each box represents the number of points/datasets in it. The median is represented by a white line and each black box represents a fourth of the population denoted by F in the legend. The next box represents a eighth denoted by an E and each successive box represents half of the previous one.


```{r table, dependson='lvplots', message=FALSE}
stats <- bind_rows(
    gmean %>%
      select(Algorithm, Gmean) %>%
      rename(value = Gmean) %>%
      mutate(Metric = "Gmean"),
    fmeas %>%
      select(Algorithm, Fmeasure) %>%
      rename(value = Fmeasure) %>%
      mutate(Metric = "Fmeasure"),
  ) %>%
  group_by(Algorithm, Metric) %>%
  summarise(
    median = median(value),
    mean = mean(value),
    sd = sd(value),
    n = n()
  ) %>%
  mutate(
    lo = mean - 1.96 * sd/sqrt(n),
    hi = mean + 1.96 * sd/sqrt(n)
  )
tab <- stats %>%
  mutate(
    CI = paste0("(",sprintf("%.4f",lo),",",sprintf("%.4f",hi),")"),
    Mean = sprintf("%.4f", mean),
    Median = sprintf("%.4f", median)
  ) %>%
  pivot_longer(c(Median, Mean, CI), names_to = "Statistic") %>%
  select(Algorithm, Metric, Statistic, value) %>%
  pivot_wider(names_from=Algorithm, values_from = value) %>%
  arrange(desc(Metric), desc(Statistic)) %>%
  mutate(
    Statistic = recode(Statistic, CI = "95% Confidence Interval")
  )
tab %>%
  select(-Metric) %>%
  knitr::kable(
    col.names = c("Statistic","lookout - HDoutliers", "lookout - stray"),
    booktabs = TRUE,
    caption = "Summary statistics for comparing lookout with the HDoutliers and stray algorithms."
  ) %>%
  kableExtra::pack_rows(index = table(tab$Metric))

gmean <- stats %>%
  filter(Metric == "Gmean") %>%
  arrange(Algorithm) %>%
  pull(median)
fmeas <- stats %>%
  filter(Metric == "Fmeasure") %>%
  arrange(Algorithm) %>%
  pull(median)
```

From the graphs in Figure \ref{fig:lvplots} we see that the total area of the letter-value plots above zero is larger than the area below zero. This signifies that more datasets have positive Gmean and F-measure values for lookout - HDoutliers and lookout - stray performance values compared to the negative values. This is confirmed by the results in Table \ref{tab:table}. We see that for both Gmean and F-measure, the median, mean and the 95\% confidence interval from Student's t-tests are away from zero. In fact, the Gmean has median values `r sprintf("%.4f",gmean[1])` and `r sprintf("%.4f",gmean[2])` for lookout - HDoutliers and lookout - stray respectively. Similarly, the corresponding F-measure values are `r sprintf("%.4f",fmeas[1])` and `r sprintf("%.4f",fmeas[2])`. Given that both Gmean and F-measure are bounded by 1, this shows that lookout gives better performance than HDoutliers or stray.

# Conclusions {#sec:conclusions}

Lookout uses leave-one-out kernel density estimates and EVT to detect outliers. Outlier detection methods that use kernel density estimates generally employ a user-defined parameter to construct the bandwidth. Selecting a bandwidth for outlier detection is different from selecting a bandwidth for general data representation, because the goal is to make outliers have lower density estimates compared to the non-outliers. In addition, it is a challenge to select an appropriate bandwidth in high dimensions. To make outliers have lower density estimates compared to the rest, a reasonably large bandwidth needs to be chosen. We introduced an algorithm called *lookout* that uses persistent homology to select the bandwidth. 

We compared the performance of lookout \textcolor{blue}{with 4 outlier detection algorithms, 2 of which use EVT to detect outliers and the others use KDE. These algorithms are HDoutliers, stray, KDEOS and RDOS.}  Our results on experimental data and on \textcolor{blue}{two data repositories} showed that lookout achieves better performance.

We also introduced the concept of *outlier persistence*, exploring the birth and death of outliers with changing bandwidth and significance values. Outlier persistence gives a bigger picture, taking a step back from fixed parameter values. It explores the bandwidth and significance parameters and highlights the outliers that persist over a range of bandwidth values and their significance levels. We suggest that it is a useful measure that increases our understanding of outliers.

# Supplementary materials {#sec:suppmat}

The R package `lookout` is available at \url{https://github.com/sevvandi/lookout}.
The outlier detection data repository used in Section \ref{sec:applications} is available at @datasets.
The programming scripts used in Sections \ref{sec:simulations} and \ref{sec:applications} are available at \url{https://github.com/sevvandi/supplementary_material/tree/master/lookout}.
